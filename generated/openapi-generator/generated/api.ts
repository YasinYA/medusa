/* tslint:disable */
/* eslint-disable */
/**
 * Medusa Admin API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * An address.
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'customer_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'company'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'address_1'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'address_2'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'country_code'?: string;
    /**
     * 
     * @type {Country}
     * @memberof Address
     */
    'country'?: Country;
}
/**
 * Represents a user cart
 * @export
 * @interface Cart
 */
export interface Cart {
    /**
     * 
     * @type {string}
     * @memberof Cart
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Cart
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof Cart
     */
    'billing_address_id'?: string;
    /**
     * 
     * @type {Address}
     * @memberof Cart
     */
    'billing_address'?: Address;
    /**
     * 
     * @type {string}
     * @memberof Cart
     */
    'shipping_address_id'?: string;
    /**
     * 
     * @type {Address}
     * @memberof Cart
     */
    'shipping_address'?: Address;
    /**
     * 
     * @type {Array<LineItem>}
     * @memberof Cart
     */
    'items'?: Array<LineItem>;
    /**
     * 
     * @type {string}
     * @memberof Cart
     */
    'region_id'?: string;
    /**
     * 
     * @type {Region}
     * @memberof Cart
     */
    'region'?: Region;
    /**
     * 
     * @type {Array<Region>}
     * @memberof Cart
     */
    'discounts'?: Array<Region>;
    /**
     * 
     * @type {Array<GiftCard>}
     * @memberof Cart
     */
    'gift_cards'?: Array<GiftCard>;
    /**
     * 
     * @type {string}
     * @memberof Cart
     */
    'customer_id'?: string;
    /**
     * 
     * @type {Customer}
     * @memberof Cart
     */
    'customer'?: Customer;
    /**
     * 
     * @type {PaymentSession}
     * @memberof Cart
     */
    'payment_session'?: PaymentSession;
    /**
     * 
     * @type {Array<PaymentSession>}
     * @memberof Cart
     */
    'payment_sessions'?: Array<PaymentSession>;
    /**
     * 
     * @type {Payment}
     * @memberof Cart
     */
    'payment'?: Payment;
    /**
     * 
     * @type {Array<ShippingMethod>}
     * @memberof Cart
     */
    'shipping_methods'?: Array<ShippingMethod>;
    /**
     * 
     * @type {string}
     * @memberof Cart
     */
    'type'?: CartTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Cart
     */
    'completed_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Cart
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Cart
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Cart
     */
    'deleted_at'?: string;
    /**
     * 
     * @type {object}
     * @memberof Cart
     */
    'metadata'?: object;
    /**
     * 
     * @type {number}
     * @memberof Cart
     */
    'shipping_total'?: number;
    /**
     * 
     * @type {number}
     * @memberof Cart
     */
    'discount_total'?: number;
    /**
     * 
     * @type {number}
     * @memberof Cart
     */
    'tax_total'?: number;
    /**
     * 
     * @type {number}
     * @memberof Cart
     */
    'subtotal'?: number;
    /**
     * 
     * @type {number}
     * @memberof Cart
     */
    'refundable_amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Cart
     */
    'gift_card_total'?: number;
}

export const CartTypeEnum = {
    Default: 'default',
    Swap: 'swap',
    PaymentLink: 'payment_link'
} as const;

export type CartTypeEnum = typeof CartTypeEnum[keyof typeof CartTypeEnum];

/**
 * Represents photo documentation of a claim.
 * @export
 * @interface ClaimImage
 */
export interface ClaimImage {
    /**
     * 
     * @type {string}
     * @memberof ClaimImage
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClaimImage
     */
    'claim_item_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClaimImage
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClaimImage
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClaimImage
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClaimImage
     */
    'deleted_at'?: string;
    /**
     * 
     * @type {object}
     * @memberof ClaimImage
     */
    'metadata'?: object;
}
/**
 * Represents a claimed item along with information about the reasons for the claim.
 * @export
 * @interface ClaimItem
 */
export interface ClaimItem {
    /**
     * 
     * @type {string}
     * @memberof ClaimItem
     */
    'id'?: string;
    /**
     * 
     * @type {Array<ClaimImage>}
     * @memberof ClaimItem
     */
    'images'?: Array<ClaimImage>;
    /**
     * 
     * @type {string}
     * @memberof ClaimItem
     */
    'claim_order_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClaimItem
     */
    'item_id'?: string;
    /**
     * 
     * @type {LineItem}
     * @memberof ClaimItem
     */
    'item'?: LineItem;
    /**
     * 
     * @type {string}
     * @memberof ClaimItem
     */
    'variant_id'?: string;
    /**
     * 
     * @type {ProductVariant}
     * @memberof ClaimItem
     */
    'variant'?: ProductVariant;
    /**
     * The reason for the claim
     * @type {string}
     * @memberof ClaimItem
     */
    'reason'?: ClaimItemReasonEnum;
    /**
     * An optional note about the claim, for additional information
     * @type {string}
     * @memberof ClaimItem
     */
    'note'?: string;
    /**
     * The quantity of the item that is being claimed; must be less than or equal to the amount purchased in the original order.
     * @type {number}
     * @memberof ClaimItem
     */
    'quantity'?: number;
    /**
     * User defined tags for easy filtering and grouping.
     * @type {Array<ClaimTag>}
     * @memberof ClaimItem
     */
    'tags'?: Array<ClaimTag>;
    /**
     * 
     * @type {string}
     * @memberof ClaimItem
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClaimItem
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClaimItem
     */
    'deleted_at'?: string;
    /**
     * 
     * @type {object}
     * @memberof ClaimItem
     */
    'metadata'?: object;
}

export const ClaimItemReasonEnum = {
    MissingItem: 'missing_item',
    WrongItem: 'wrong_item',
    ProductionFailure: 'production_failure',
    Other: 'other'
} as const;

export type ClaimItemReasonEnum = typeof ClaimItemReasonEnum[keyof typeof ClaimItemReasonEnum];

/**
 * Claim Orders represent a group of faulty or missing items. Each claim order consists of a subset of items associated with an original order, and can contain additional information about fulfillments and returns.
 * @export
 * @interface ClaimOrder
 */
export interface ClaimOrder {
    /**
     * 
     * @type {string}
     * @memberof ClaimOrder
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClaimOrder
     */
    'type'?: ClaimOrderTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ClaimOrder
     */
    'payment_status'?: ClaimOrderPaymentStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ClaimOrder
     */
    'fulfillment_status'?: ClaimOrderFulfillmentStatusEnum;
    /**
     * The items that have been claimed
     * @type {Array<ClaimItem>}
     * @memberof ClaimOrder
     */
    'claim_items'?: Array<ClaimItem>;
    /**
     * Refers to the new items to be shipped when the claim order has the type `replace`
     * @type {Array<LineItem>}
     * @memberof ClaimOrder
     */
    'additional_items'?: Array<LineItem>;
    /**
     * The id of the order that the claim comes from.
     * @type {string}
     * @memberof ClaimOrder
     */
    'order_id'?: string;
    /**
     * 
     * @type {Return}
     * @memberof ClaimOrder
     */
    'return_order'?: Return;
    /**
     * The id of the address that the new items should be shipped to
     * @type {string}
     * @memberof ClaimOrder
     */
    'shipping_address_id'?: string;
    /**
     * 
     * @type {Address}
     * @memberof ClaimOrder
     */
    'shipping_address'?: Address;
    /**
     * The shipping methods that the claim order will be shipped with.
     * @type {Array<ShippingMethod>}
     * @memberof ClaimOrder
     */
    'shipping_methods'?: Array<ShippingMethod>;
    /**
     * The fulfillments of the new items to be shipped
     * @type {Array<Fulfillment>}
     * @memberof ClaimOrder
     */
    'fulfillments'?: Array<Fulfillment>;
    /**
     * The amount that will be refunded in conjunction with the claim
     * @type {number}
     * @memberof ClaimOrder
     */
    'refund_amount'?: number;
    /**
     * The date with timezone at which the Swap was canceled.
     * @type {string}
     * @memberof ClaimOrder
     */
    'canceled_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClaimOrder
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClaimOrder
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClaimOrder
     */
    'deleted_at'?: string;
    /**
     * Flag for describing whether or not notifications related to this should be send.
     * @type {boolean}
     * @memberof ClaimOrder
     */
    'no_notification'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof ClaimOrder
     */
    'metadata'?: object;
}

export const ClaimOrderTypeEnum = {
    Refund: 'refund',
    Replace: 'replace'
} as const;

export type ClaimOrderTypeEnum = typeof ClaimOrderTypeEnum[keyof typeof ClaimOrderTypeEnum];
export const ClaimOrderPaymentStatusEnum = {
    Na: 'na',
    NotRefunded: 'not_refunded',
    Refunded: 'refunded'
} as const;

export type ClaimOrderPaymentStatusEnum = typeof ClaimOrderPaymentStatusEnum[keyof typeof ClaimOrderPaymentStatusEnum];
export const ClaimOrderFulfillmentStatusEnum = {
    NotFulfilled: 'not_fulfilled',
    PartiallyFulfilled: 'partially_fulfilled',
    Fulfilled: 'fulfilled',
    PartiallyShipped: 'partially_shipped',
    Shipped: 'shipped',
    PartiallyReturned: 'partially_returned',
    Returned: 'returned',
    Canceled: 'canceled',
    RequiresAction: 'requires_action'
} as const;

export type ClaimOrderFulfillmentStatusEnum = typeof ClaimOrderFulfillmentStatusEnum[keyof typeof ClaimOrderFulfillmentStatusEnum];

/**
 * Claim Tags are user defined tags that can be assigned to claim items for easy filtering and grouping.
 * @export
 * @interface ClaimTag
 */
export interface ClaimTag {
    /**
     * The id of the claim tag. Will be prefixed by `ctag_`.
     * @type {string}
     * @memberof ClaimTag
     */
    'id'?: string;
    /**
     * The value that the claim tag holds
     * @type {string}
     * @memberof ClaimTag
     */
    'value'?: string;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof ClaimTag
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof ClaimTag
     */
    'update_at'?: string;
    /**
     * The date with timezone at which the resource was deleted.
     * @type {string}
     * @memberof ClaimTag
     */
    'deleted_at'?: string;
    /**
     * An optional key-value map with additional information.
     * @type {object}
     * @memberof ClaimTag
     */
    'metadata'?: object;
}
/**
 * Country details
 * @export
 * @interface Country
 */
export interface Country {
    /**
     * The database id of the country
     * @type {number}
     * @memberof Country
     */
    'id'?: number;
    /**
     * The 2 character ISO code for the country.
     * @type {string}
     * @memberof Country
     */
    'iso_2'?: string;
    /**
     * The 3 character ISO code for the country.
     * @type {string}
     * @memberof Country
     */
    'iso_3'?: string;
    /**
     * The numerical ISO code for the country.
     * @type {string}
     * @memberof Country
     */
    'num_code'?: string;
    /**
     * The normalized country name; in upper case.
     * @type {string}
     * @memberof Country
     */
    'name'?: string;
    /**
     * The country name appropriate for display.
     * @type {string}
     * @memberof Country
     */
    'display_name'?: string;
}
/**
 * Currency
 * @export
 * @interface Currency
 */
export interface Currency {
    /**
     * The 3 character ISO code for the currency.
     * @type {string}
     * @memberof Currency
     */
    'code'?: string;
    /**
     * The symbol used to indicate the currency.
     * @type {string}
     * @memberof Currency
     */
    'symbol'?: string;
    /**
     * The native symbol used to indicate the currency.
     * @type {string}
     * @memberof Currency
     */
    'symbol_native'?: string;
    /**
     * The written name of the currency
     * @type {string}
     * @memberof Currency
     */
    'name'?: string;
}
/**
 * Custom Shipping Options are \'overriden\' Shipping Options. Store managers can attach a Custom Shipping Option to a cart in order to set a custom price for a particular Shipping Option
 * @export
 * @interface CustomShippingOption
 */
export interface CustomShippingOption {
    /**
     * The id of the Custom Shipping Option. This value will be prefixed with `cso_`.
     * @type {string}
     * @memberof CustomShippingOption
     */
    'id'?: string;
    /**
     * The custom price set that will override the shipping option\'s original price
     * @type {number}
     * @memberof CustomShippingOption
     */
    'price'?: number;
    /**
     * The id of the Shipping Option that the custom shipping option overrides
     * @type {ShippingOption}
     * @memberof CustomShippingOption
     */
    'shipping_option_id'?: ShippingOption;
    /**
     * The id of the Cart that the custom shipping option is attached to
     * @type {Cart}
     * @memberof CustomShippingOption
     */
    'cart_id'?: Cart;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof CustomShippingOption
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof CustomShippingOption
     */
    'updated_at'?: string;
    /**
     * The date with timezone at which the resource was deleted.
     * @type {string}
     * @memberof CustomShippingOption
     */
    'deleted_at'?: string;
    /**
     * An optional key-value map with additional information.
     * @type {object}
     * @memberof CustomShippingOption
     */
    'metadata'?: object;
}
/**
 * Represents a customer
 * @export
 * @interface Customer
 */
export interface Customer {
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'billing_address_id'?: string;
    /**
     * The Customer\'s billing address.
     * @type {Address}
     * @memberof Customer
     */
    'billing_address'?: Address;
    /**
     * 
     * @type {Array<Address>}
     * @memberof Customer
     */
    'shipping_addresses'?: Array<Address>;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'phone'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Customer
     */
    'has_account'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'deleted_at'?: string;
    /**
     * 
     * @type {object}
     * @memberof Customer
     */
    'metadata'?: object;
}
/**
 * Represents a customer group
 * @export
 * @interface CustomerGroup
 */
export interface CustomerGroup {
    /**
     * 
     * @type {string}
     * @memberof CustomerGroup
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerGroup
     */
    'name'?: string;
    /**
     * 
     * @type {Array<Customer>}
     * @memberof CustomerGroup
     */
    'customers'?: Array<Customer>;
    /**
     * 
     * @type {string}
     * @memberof CustomerGroup
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerGroup
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerGroup
     */
    'deleted_at'?: string;
    /**
     * 
     * @type {object}
     * @memberof CustomerGroup
     */
    'metadata'?: object;
}
/**
 * Represents a discount that can be applied to a cart for promotional purposes.
 * @export
 * @interface Discount
 */
export interface Discount {
    /**
     * The id of the Discount. Will be prefixed by `disc_`.
     * @type {string}
     * @memberof Discount
     */
    'id'?: string;
    /**
     * A unique code for the discount - this will be used by the customer to apply the discount
     * @type {string}
     * @memberof Discount
     */
    'code'?: string;
    /**
     * A flag to indicate if multiple instances of the discount can be generated. I.e. for newsletter discounts
     * @type {boolean}
     * @memberof Discount
     */
    'is_dynamic'?: boolean;
    /**
     * The Discount Rule that governs the behaviour of the Discount
     * @type {DiscountRule}
     * @memberof Discount
     */
    'rule'?: DiscountRule;
    /**
     * Whether the Discount has been disabled. Disabled discounts cannot be applied to carts
     * @type {boolean}
     * @memberof Discount
     */
    'is_disabled'?: boolean;
    /**
     * The Discount that the discount was created from. This will always be a dynamic discount
     * @type {string}
     * @memberof Discount
     */
    'parent_discount_id'?: string;
    /**
     * The time at which the discount can be used.
     * @type {string}
     * @memberof Discount
     */
    'starts_at'?: string;
    /**
     * The time at which the discount can no longer be used.
     * @type {string}
     * @memberof Discount
     */
    'ends_at'?: string;
    /**
     * The Regions in which the Discount can be used
     * @type {Array<Region>}
     * @memberof Discount
     */
    'regions'?: Array<Region>;
    /**
     * The maximum number of times that a discount can be used.
     * @type {number}
     * @memberof Discount
     */
    'usage_limit'?: number;
    /**
     * The number of times a discount has been used.
     * @type {number}
     * @memberof Discount
     */
    'usage_count'?: number;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof Discount
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof Discount
     */
    'updated_at'?: string;
    /**
     * The date with timezone at which the resource was deleted.
     * @type {string}
     * @memberof Discount
     */
    'deleted_at'?: string;
    /**
     * An optional key-value map with additional information.
     * @type {object}
     * @memberof Discount
     */
    'metadata'?: object;
}
/**
 * Holds the rules that governs how a Discount is calculated when applied to a Cart.
 * @export
 * @interface DiscountRule
 */
export interface DiscountRule {
    /**
     * The id of the Discount Rule. Will be prefixed by `dru_`.
     * @type {string}
     * @memberof DiscountRule
     */
    'id'?: string;
    /**
     * The type of the Discount, can be `fixed` for discounts that reduce the price by a fixed amount, `percentage` for percentage reductions or `free_shipping` for shipping vouchers.
     * @type {string}
     * @memberof DiscountRule
     */
    'type'?: DiscountRuleTypeEnum;
    /**
     * A short description of the discount
     * @type {string}
     * @memberof DiscountRule
     */
    'description'?: string;
    /**
     * The value that the discount represents; this will depend on the type of the discount
     * @type {number}
     * @memberof DiscountRule
     */
    'value'?: number;
    /**
     * The scope that the discount should apply to.
     * @type {string}
     * @memberof DiscountRule
     */
    'allocation'?: DiscountRuleAllocationEnum;
    /**
     * A set of Products that the discount can be used for.
     * @type {Array<Product>}
     * @memberof DiscountRule
     */
    'valid_for'?: Array<Product>;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof DiscountRule
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof DiscountRule
     */
    'update_at'?: string;
    /**
     * The date with timezone at which the resource was deleted.
     * @type {string}
     * @memberof DiscountRule
     */
    'deleted_at'?: string;
    /**
     * An optional key-value map with additional information.
     * @type {object}
     * @memberof DiscountRule
     */
    'metadata'?: object;
}

export const DiscountRuleTypeEnum = {
    Fixed: 'fixed',
    Percentage: 'percentage',
    FreeShipping: 'free_shipping'
} as const;

export type DiscountRuleTypeEnum = typeof DiscountRuleTypeEnum[keyof typeof DiscountRuleTypeEnum];
export const DiscountRuleAllocationEnum = {
    Total: 'total',
    Item: 'item'
} as const;

export type DiscountRuleAllocationEnum = typeof DiscountRuleAllocationEnum[keyof typeof DiscountRuleAllocationEnum];

/**
 * Represents a draft order
 * @export
 * @interface DraftOrder
 */
export interface DraftOrder {
    /**
     * 
     * @type {string}
     * @memberof DraftOrder
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DraftOrder
     */
    'status'?: DraftOrderStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof DraftOrder
     */
    'display_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DraftOrder
     */
    'cart_id'?: string;
    /**
     * 
     * @type {Cart}
     * @memberof DraftOrder
     */
    'cart'?: Cart;
    /**
     * 
     * @type {string}
     * @memberof DraftOrder
     */
    'order_id'?: string;
    /**
     * 
     * @type {Order}
     * @memberof DraftOrder
     */
    'order'?: Order;
    /**
     * 
     * @type {string}
     * @memberof DraftOrder
     */
    'canceled_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DraftOrder
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DraftOrder
     */
    'update_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DraftOrder
     */
    'deleted_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DraftOrder
     */
    'completed_at'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DraftOrder
     */
    'no_notification_order'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof DraftOrder
     */
    'metadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof DraftOrder
     */
    'idempotency_key'?: string;
}

export const DraftOrderStatusEnum = {
    Open: 'open',
    Completed: 'completed'
} as const;

export type DraftOrderStatusEnum = typeof DraftOrderStatusEnum[keyof typeof DraftOrderStatusEnum];

/**
 * Fulfillments are created once store operators can prepare the purchased goods. Fulfillments will eventually be shipped and hold information about how to track shipments. Fulfillments are created through a provider, which is typically an external shipping aggregator, shipping partner og 3PL, most plugins will have asynchronous communications with these providers through webhooks in order to automatically update and synchronize the state of Fulfillments.
 * @export
 * @interface Fulfillment
 */
export interface Fulfillment {
    /**
     * The id of the Fulfillment. This value will be prefixed by `ful_`.
     * @type {string}
     * @memberof Fulfillment
     */
    'id'?: string;
    /**
     * The id of the Claim that the Fulfillment belongs to.
     * @type {string}
     * @memberof Fulfillment
     */
    'claim_order_id'?: string;
    /**
     * The id of the Swap that the Fulfillment belongs to.
     * @type {string}
     * @memberof Fulfillment
     */
    'swap_id'?: string;
    /**
     * The id of the Order that the Fulfillment belongs to.
     * @type {string}
     * @memberof Fulfillment
     */
    'order_id'?: string;
    /**
     * The id of the Fulfillment Provider responsible for handling the fulfillment
     * @type {string}
     * @memberof Fulfillment
     */
    'provider_id'?: string;
    /**
     * The Fulfillment Items in the Fulfillment - these hold information about how many of each Line Item has been fulfilled.
     * @type {Array<FulfillmentItem>}
     * @memberof Fulfillment
     */
    'items'?: Array<FulfillmentItem>;
    /**
     * The Tracking Links that can be used to track the status of the Fulfillment, these will usually be provided by the Fulfillment Provider.
     * @type {Array<TrackingLink>}
     * @memberof Fulfillment
     */
    'tracking_links'?: Array<TrackingLink>;
    /**
     * The tracking numbers that can be used to track the status of the fulfillment.
     * @type {Array<string>}
     * @memberof Fulfillment
     * @deprecated
     */
    'tracking_numbers'?: Array<string>;
    /**
     * The date with timezone at which the Fulfillment was shipped.
     * @type {string}
     * @memberof Fulfillment
     */
    'shipped_at'?: string;
    /**
     * Flag for describing whether or not notifications related to this should be send.
     * @type {boolean}
     * @memberof Fulfillment
     */
    'no_notification'?: boolean;
    /**
     * The date with timezone at which the Fulfillment was canceled.
     * @type {string}
     * @memberof Fulfillment
     */
    'canceled_at'?: string;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof Fulfillment
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof Fulfillment
     */
    'updated_at'?: string;
    /**
     * An optional key-value map with additional information.
     * @type {object}
     * @memberof Fulfillment
     */
    'metadata'?: object;
}
/**
 * Correlates a Line Item with a Fulfillment, keeping track of the quantity of the Line Item.
 * @export
 * @interface FulfillmentItem
 */
export interface FulfillmentItem {
    /**
     * The id of the Fulfillment that the Fulfillment Item belongs to.
     * @type {string}
     * @memberof FulfillmentItem
     */
    'fulfillment_id'?: string;
    /**
     * The id of the Line Item that the Fulfillment Item references.
     * @type {string}
     * @memberof FulfillmentItem
     */
    'item_id'?: string;
    /**
     * The Line Item that the Fulfillment Item references.
     * @type {LineItem}
     * @memberof FulfillmentItem
     */
    'item'?: LineItem;
    /**
     * The quantity of the Line Item that is included in the Fulfillment.
     * @type {number}
     * @memberof FulfillmentItem
     */
    'quantity'?: number;
}
/**
 * Represents a fulfillment provider plugin and holds its installation status.
 * @export
 * @interface FulfillmentProvider
 */
export interface FulfillmentProvider {
    /**
     * The id of the fulfillment provider as given by the plugin.
     * @type {string}
     * @memberof FulfillmentProvider
     */
    'id'?: string;
    /**
     * Whether the plugin is installed in the current version. Plugins that are no longer installed are not deleted by will have this field set to `false`.
     * @type {boolean}
     * @memberof FulfillmentProvider
     */
    'is_installed'?: boolean;
}
/**
 * Gift Cards are redeemable and represent a value that can be used towards the payment of an Order.
 * @export
 * @interface GiftCard
 */
export interface GiftCard {
    /**
     * The id of the Gift Card. This value will be prefixed by `gift_`.
     * @type {string}
     * @memberof GiftCard
     */
    'id'?: string;
    /**
     * The unique code that identifies the Gift Card. This is used by the Customer to redeem the value of the Gift Card.
     * @type {string}
     * @memberof GiftCard
     */
    'code'?: string;
    /**
     * The value that the Gift Card represents.
     * @type {number}
     * @memberof GiftCard
     */
    'value'?: number;
    /**
     * The remaining value on the Gift Card.
     * @type {number}
     * @memberof GiftCard
     */
    'balance'?: number;
    /**
     * The id of the Region in which the Gift Card is available.
     * @type {string}
     * @memberof GiftCard
     */
    'region_id'?: string;
    /**
     * The Region in which the Gift Card is available.
     * @type {Region}
     * @memberof GiftCard
     */
    'region'?: Region;
    /**
     * The id of the Order that the Gift Card was purchased in.
     * @type {string}
     * @memberof GiftCard
     */
    'order_id'?: string;
    /**
     * Whether the Gift Card has been disabled. Disabled Gift Cards cannot be applied to carts.
     * @type {boolean}
     * @memberof GiftCard
     */
    'is_disabled'?: boolean;
    /**
     * The time at which the Gift Card can no longer be used.
     * @type {string}
     * @memberof GiftCard
     */
    'ends_at'?: string;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof GiftCard
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof GiftCard
     */
    'updated_at'?: string;
    /**
     * The date with timezone at which the resource was deleted.
     * @type {string}
     * @memberof GiftCard
     */
    'deleted_at'?: string;
    /**
     * An optional key-value map with additional information.
     * @type {object}
     * @memberof GiftCard
     */
    'metadata'?: object;
}
/**
 * Gift Card Transactions are created once a Customer uses a Gift Card to pay for their Order
 * @export
 * @interface GiftCardTransaction
 */
export interface GiftCardTransaction {
    /**
     * The id of the Gift Card Transaction. This value will be prefixed by `gct_`.
     * @type {string}
     * @memberof GiftCardTransaction
     */
    'id'?: string;
    /**
     * The id of the Gift Card that was used in the transaction.
     * @type {string}
     * @memberof GiftCardTransaction
     */
    'gift_card_id'?: string;
    /**
     * The Gift Card that was used in the transaction.
     * @type {GiftCard}
     * @memberof GiftCardTransaction
     */
    'gift_card'?: GiftCard;
    /**
     * The id of the Order that the Gift Card was used to pay for.
     * @type {string}
     * @memberof GiftCardTransaction
     */
    'order_id'?: string;
    /**
     * The amount that was used from the Gift Card.
     * @type {number}
     * @memberof GiftCardTransaction
     */
    'amount'?: number;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof GiftCardTransaction
     */
    'created_at'?: string;
}
/**
 * Images holds a reference to a URL at which the image file can be found.
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * The id of the Image. This value will be prefixed by `img_`.
     * @type {string}
     * @memberof Image
     */
    'id'?: string;
    /**
     * The URL at which the image file can be found.
     * @type {string}
     * @memberof Image
     */
    'url'?: string;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof Image
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof Image
     */
    'update_at'?: string;
    /**
     * The date with timezone at which the resource was deleted.
     * @type {string}
     * @memberof Image
     */
    'deleted_at'?: string;
    /**
     * An optional key-value map with additional information.
     * @type {object}
     * @memberof Image
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * The User\'s email.
     * @type {string}
     * @memberof InlineObject
     */
    'email': string;
    /**
     * The User\'s password.
     * @type {string}
     * @memberof InlineObject
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * The Customer\'s email address.
     * @type {string}
     * @memberof InlineObject1
     */
    'email': string;
    /**
     * The Customer\'s first name.
     * @type {string}
     * @memberof InlineObject1
     */
    'first_name': string;
    /**
     * The Customer\'s last name.
     * @type {string}
     * @memberof InlineObject1
     */
    'last_name': string;
    /**
     * The Customer\'s phone number.
     * @type {string}
     * @memberof InlineObject1
     */
    'phone'?: string;
    /**
     * Metadata for the customer.
     * @type {object}
     * @memberof InlineObject1
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
    /**
     * Name of the customer group
     * @type {string}
     * @memberof InlineObject2
     */
    'name': string;
    /**
     * Metadata for the customer.
     * @type {object}
     * @memberof InlineObject2
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
    /**
     * Name of the customer group
     * @type {string}
     * @memberof InlineObject3
     */
    'name': string;
    /**
     * Metadata for the customer.
     * @type {object}
     * @memberof InlineObject3
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface InlineObject4
 */
export interface InlineObject4 {
    /**
     * The unique code that will be used to redeem the Discount.
     * @type {string}
     * @memberof InlineObject4
     */
    'code': string;
    /**
     * An optional set of key-value paris to hold additional information.
     * @type {object}
     * @memberof InlineObject4
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface InlineObject5
 */
export interface InlineObject5 {
    /**
     * The price (excluding VAT) that should be charged for the Shipping Method
     * @type {number}
     * @memberof InlineObject5
     */
    'price': number;
    /**
     * The id of the Shipping Option to create the Shipping Method from.
     * @type {string}
     * @memberof InlineObject5
     */
    'option_id': string;
    /**
     * The data required for the Shipping Option to create a Shipping Method. This will depend on the Fulfillment Provider.
     * @type {object}
     * @memberof InlineObject5
     */
    'data': object;
}
/**
 * 
 * @export
 * @interface InlineObject6
 */
export interface InlineObject6 {
    /**
     * Key for the metadata value.
     * @type {string}
     * @memberof InlineObject6
     */
    'key': string;
    /**
     * The value that the key relates to.
     * @type {string}
     * @memberof InlineObject6
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface InlineObject8
 */
export interface InlineObject8 {
    /**
     * The name of the User.
     * @type {string}
     * @memberof InlineObject8
     */
    'first_name': string;
    /**
     * The name of the User.
     * @type {string}
     * @memberof InlineObject8
     */
    'last_name': string;
    /**
     * The role of the User(admin, member, developer).
     * @type {string}
     * @memberof InlineObject8
     */
    'role': string;
    /**
     * The api_token of the User.
     * @type {string}
     * @memberof InlineObject8
     */
    'api_token': string;
}
/**
 * Represents an invite
 * @export
 * @interface Invite
 */
export interface Invite {
    /**
     * 
     * @type {string}
     * @memberof Invite
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Invite
     */
    'user_email'?: string;
    /**
     * 
     * @type {string}
     * @memberof Invite
     */
    'role'?: InviteRoleEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Invite
     */
    'accepted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Invite
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof Invite
     */
    'expores_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Invite
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Invite
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Invite
     */
    'deleted_at'?: string;
    /**
     * 
     * @type {object}
     * @memberof Invite
     */
    'metadata'?: object;
}

export const InviteRoleEnum = {
    Admin: 'admin',
    Member: 'member',
    Developer: 'developer'
} as const;

export type InviteRoleEnum = typeof InviteRoleEnum[keyof typeof InviteRoleEnum];

/**
 * Line Items represent purchasable units that can be added to a Cart for checkout. When Line Items are purchased they will get copied to the resulting order and can eventually be referenced in Fulfillments and Returns. Line Items may also be created when processing Swaps and Claims.
 * @export
 * @interface LineItem
 */
export interface LineItem {
    /**
     * The id of the Line Item. This value will be prefixed by `item_`.
     * @type {string}
     * @memberof LineItem
     */
    'id'?: string;
    /**
     * The id of the Cart that the Line Item belongs to.
     * @type {string}
     * @memberof LineItem
     */
    'cart_id'?: string;
    /**
     * The id of the Order that the Line Item belongs to.
     * @type {string}
     * @memberof LineItem
     */
    'order_id'?: string;
    /**
     * The id of the Swap that the Line Item belongs to.
     * @type {string}
     * @memberof LineItem
     */
    'swap_id'?: string;
    /**
     * The id of the Claim that the Line Item belongs to.
     * @type {string}
     * @memberof LineItem
     */
    'claim_order_id'?: string;
    /**
     * The title of the Line Item, this should be easily identifiable by the Customer.
     * @type {string}
     * @memberof LineItem
     */
    'title'?: string;
    /**
     * A more detailed description of the contents of the Line Item.
     * @type {string}
     * @memberof LineItem
     */
    'description'?: string;
    /**
     * A URL string to a small image of the contents of the Line Item.
     * @type {string}
     * @memberof LineItem
     */
    'thumbnail'?: string;
    /**
     * Flag to indicate if the Line Item is a Gift Card.
     * @type {boolean}
     * @memberof LineItem
     */
    'is_giftcard'?: boolean;
    /**
     * Flag to indicate if new Line Items with the same variant should be merged or added as an additional Line Item.
     * @type {boolean}
     * @memberof LineItem
     */
    'should_merge'?: boolean;
    /**
     * Flag to indicate if the Line Item should be included when doing discount calculations.
     * @type {boolean}
     * @memberof LineItem
     */
    'allow_discounts'?: boolean;
    /**
     * The price of one unit of the content in the Line Item. This should be in the currency defined by the Cart/Order/Swap/Claim that the Line Item belongs to.
     * @type {boolean}
     * @memberof LineItem
     */
    'unit_price'?: boolean;
    /**
     * The id of the Product Variant contained in the Line Item.
     * @type {string}
     * @memberof LineItem
     */
    'variant_id'?: string;
    /**
     * The Product Variant contained in the Line Item.
     * @type {ProductVariant}
     * @memberof LineItem
     */
    'variant'?: ProductVariant;
    /**
     * The quantity of the content in the Line Item.
     * @type {number}
     * @memberof LineItem
     */
    'quantity'?: number;
    /**
     * The quantity of the Line Item that has been fulfilled.
     * @type {number}
     * @memberof LineItem
     */
    'fulfilled_quantity'?: number;
    /**
     * The quantity of the Line Item that has been returned.
     * @type {number}
     * @memberof LineItem
     */
    'returned_quantity'?: number;
    /**
     * The quantity of the Line Item that has been shipped.
     * @type {number}
     * @memberof LineItem
     */
    'shipped_quantity'?: number;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof LineItem
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof LineItem
     */
    'updated_at'?: string;
    /**
     * An optional key-value map with additional information.
     * @type {object}
     * @memberof LineItem
     */
    'metadata'?: object;
    /**
     * The amount that can be refunded from the given Line Item. Takes taxes and discounts into consideration.
     * @type {number}
     * @memberof LineItem
     */
    'refundable'?: number;
}
/**
 * Money Amounts represents an amount that a given Product Variant can be purcased for. Each Money Amount either has a Currency or Region associated with it to indicate the pricing in a given Currency or, for fully region-based pricing, the given price in a specific Region. If region-based pricing is used the amount will be in the currency defined for the Reigon.
 * @export
 * @interface MoneyAmount
 */
export interface MoneyAmount {
    /**
     * The id of the Money Amount. This value will be prefixed by `ma_`.
     * @type {string}
     * @memberof MoneyAmount
     */
    'id'?: string;
    /**
     * The 3 character currency code that the Money Amount is given in.
     * @type {string}
     * @memberof MoneyAmount
     */
    'currency_code'?: string;
    /**
     * The amount in the smallest currecny unit (e.g. cents 100 cents to charge $1) that the Product Variant will cost.
     * @type {number}
     * @memberof MoneyAmount
     */
    'amount'?: number;
    /**
     * An optional sale amount that the Product Variant will be available for when defined.
     * @type {number}
     * @memberof MoneyAmount
     */
    'sale_amount'?: number;
    /**
     * The id of the Product Variant that the Money Amount belongs to.
     * @type {string}
     * @memberof MoneyAmount
     */
    'variant_id'?: string;
    /**
     * The id of the Region that the Money Amount is defined for.
     * @type {string}
     * @memberof MoneyAmount
     */
    'region_id'?: string;
    /**
     * The Region that the Money Amount is defined for.
     * @type {Region}
     * @memberof MoneyAmount
     */
    'region'?: Region;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof MoneyAmount
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof MoneyAmount
     */
    'updated_at'?: string;
    /**
     * The date with timezone at which the resource was deleted.
     * @type {string}
     * @memberof MoneyAmount
     */
    'deleted_at'?: string;
}
/**
 * Notes are elements which we can use in association with different resources to allow users to describe additional information in relation to these.
 * @export
 * @interface Note
 */
export interface Note {
    /**
     * The id of the Note. This value will be prefixed by `note_`.
     * @type {string}
     * @memberof Note
     */
    'id'?: string;
    /**
     * The type of resource that the Note refers to.
     * @type {string}
     * @memberof Note
     */
    'resource_type'?: string;
    /**
     * The id of the resource that the Note refers to.
     * @type {string}
     * @memberof Note
     */
    'resource_id'?: string;
    /**
     * The contents of the note.
     * @type {string}
     * @memberof Note
     */
    'value'?: string;
    /**
     * The author of the note.
     * @type {User}
     * @memberof Note
     */
    'author'?: User;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof Note
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof Note
     */
    'updated_at'?: string;
    /**
     * The date with timezone at which the resource was deleted.
     * @type {string}
     * @memberof Note
     */
    'deleted_at'?: string;
    /**
     * An optional key-value map with additional information.
     * @type {object}
     * @memberof Note
     */
    'metadata'?: object;
}
/**
 * Notifications a communications sent via Notification Providers as a reaction to internal events such as `order.placed`. Notifications can be used to show a chronological timeline for communications sent to a Customer regarding an Order, and enables resends.
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     * The id of the Notification. This value will be prefixed by `noti_`.
     * @type {string}
     * @memberof Notification
     */
    'id'?: string;
    /**
     * The name of the event that the notification was sent for.
     * @type {string}
     * @memberof Notification
     */
    'event_name'?: string;
    /**
     * The type of resource that the Notification refers to.
     * @type {string}
     * @memberof Notification
     */
    'resource_type'?: string;
    /**
     * The id of the resource that the Notification refers to.
     * @type {string}
     * @memberof Notification
     */
    'resource_id'?: string;
    /**
     * The id of the Customer that the Notification was sent to.
     * @type {string}
     * @memberof Notification
     */
    'customer_id'?: string;
    /**
     * The Customer that the Notification was sent to.
     * @type {Customer}
     * @memberof Notification
     */
    'customer'?: Customer;
    /**
     * The address that the Notification was sent to. This will usually be an email address, but represent other addresses such as a chat bot user id
     * @type {string}
     * @memberof Notification
     */
    'to'?: string;
    /**
     * The data that the Notification was sent with. This contains all the data necessary for the Notification Provider to initiate a resend.
     * @type {object}
     * @memberof Notification
     */
    'data'?: object;
    /**
     * The id of the Notification that was originally sent.
     * @type {string}
     * @memberof Notification
     */
    'parent_id'?: string;
    /**
     * The resends that have been completed after the original Notification.
     * @type {Array<NotificationResend>}
     * @memberof Notification
     */
    'resends'?: Array<NotificationResend>;
    /**
     * The id of the Notification Provider that handles the Notification.
     * @type {string}
     * @memberof Notification
     */
    'provider_id'?: string;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof Notification
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof Notification
     */
    'updated_at'?: string;
}
/**
 * Represents a notification provider plugin and holds its installation status.
 * @export
 * @interface NotificationProvider
 */
export interface NotificationProvider {
    /**
     * The id of the notification provider as given by the plugin.
     * @type {string}
     * @memberof NotificationProvider
     */
    'id'?: string;
    /**
     * Whether the plugin is installed in the current version. Plugins that are no longer installed are not deleted by will have this field set to `false`.
     * @type {boolean}
     * @memberof NotificationProvider
     */
    'is_installed'?: boolean;
}
/**
 * A resend of a Notification.
 * @export
 * @interface NotificationResend
 */
export interface NotificationResend {
    /**
     * The id of the Notification. This value will be prefixed by `noti_`.
     * @type {string}
     * @memberof NotificationResend
     */
    'id'?: string;
    /**
     * The name of the event that the notification was sent for.
     * @type {string}
     * @memberof NotificationResend
     */
    'event_name'?: string;
    /**
     * The type of resource that the Notification refers to.
     * @type {string}
     * @memberof NotificationResend
     */
    'resource_type'?: string;
    /**
     * The id of the resource that the Notification refers to.
     * @type {string}
     * @memberof NotificationResend
     */
    'resource_id'?: string;
    /**
     * The address that the Notification was sent to. This will usually be an email address, but represent other addresses such as a chat bot user id
     * @type {string}
     * @memberof NotificationResend
     */
    'to'?: string;
    /**
     * The data that the Notification was sent with. This contains all the data necessary for the Notification Provider to initiate a resend.
     * @type {object}
     * @memberof NotificationResend
     */
    'data'?: object;
    /**
     * The id of the Notification that was originally sent.
     * @type {string}
     * @memberof NotificationResend
     */
    'parent_id'?: string;
    /**
     * The id of the Notification Provider that handles the Notification.
     * @type {string}
     * @memberof NotificationResend
     */
    'provider_id'?: string;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof NotificationResend
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof NotificationResend
     */
    'updated_at'?: string;
}
/**
 * Represent an OAuth app
 * @export
 * @interface OAuth
 */
export interface OAuth {
    /**
     * 
     * @type {string}
     * @memberof OAuth
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuth
     */
    'display_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuth
     */
    'application_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuth
     */
    'install_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof OAuth
     */
    'uninstall_url'?: number;
    /**
     * 
     * @type {object}
     * @memberof OAuth
     */
    'data'?: object;
}
/**
 * Represents an order
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'status'?: OrderStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'fulfillment_status'?: OrderFulfillmentStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'payment_status'?: OrderPaymentStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'display_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'cart_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'currency_code'?: string;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'tax_rate'?: number;
    /**
     * 
     * @type {Array<Discount>}
     * @memberof Order
     */
    'discounts'?: Array<Discount>;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'billing_address_id'?: string;
    /**
     * 
     * @type {Address}
     * @memberof Order
     */
    'billing_address'?: Address;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'shipping_address_id'?: string;
    /**
     * 
     * @type {Address}
     * @memberof Order
     */
    'shipping_address'?: Address;
    /**
     * 
     * @type {Array<LineItem>}
     * @memberof Order
     */
    'items'?: Array<LineItem>;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'region_id'?: string;
    /**
     * 
     * @type {Region}
     * @memberof Order
     */
    'region'?: Region;
    /**
     * 
     * @type {Array<GiftCard>}
     * @memberof Order
     */
    'gift_cards'?: Array<GiftCard>;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'customer_id'?: string;
    /**
     * 
     * @type {Customer}
     * @memberof Order
     */
    'customer'?: Customer;
    /**
     * 
     * @type {PaymentSession}
     * @memberof Order
     */
    'payment_session'?: PaymentSession;
    /**
     * 
     * @type {Array<PaymentSession>}
     * @memberof Order
     */
    'payment_sessions'?: Array<PaymentSession>;
    /**
     * 
     * @type {Array<Payment>}
     * @memberof Order
     */
    'payments'?: Array<Payment>;
    /**
     * 
     * @type {Array<ShippingMethod>}
     * @memberof Order
     */
    'shipping_methods'?: Array<ShippingMethod>;
    /**
     * 
     * @type {Array<Fulfillment>}
     * @memberof Order
     */
    'fulfillments'?: Array<Fulfillment>;
    /**
     * 
     * @type {Array<Return>}
     * @memberof Order
     */
    'returns'?: Array<Return>;
    /**
     * 
     * @type {Array<ClaimOrder>}
     * @memberof Order
     */
    'claims'?: Array<ClaimOrder>;
    /**
     * 
     * @type {Array<Refund>}
     * @memberof Order
     */
    'refunds'?: Array<Refund>;
    /**
     * 
     * @type {Array<Refund>}
     * @memberof Order
     */
    'swaps'?: Array<Refund>;
    /**
     * 
     * @type {Array<GiftCardTransaction>}
     * @memberof Order
     */
    'gift_card_transactions'?: Array<GiftCardTransaction>;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'canceled_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'update_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'deleted_at'?: string;
    /**
     * 
     * @type {object}
     * @memberof Order
     */
    'metadata'?: object;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'shipping_total'?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'discount_total'?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'tax_total'?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'subtotal'?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'refundable_amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'gift_card_total'?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'paid_total'?: number;
    /**
     * Flag for describing whether or not notifications related to this should be send.
     * @type {boolean}
     * @memberof Order
     */
    'no_notification'?: boolean;
}

export const OrderStatusEnum = {
    Pending: 'pending',
    Completed: 'completed',
    Archived: 'archived',
    Canceled: 'canceled',
    RequiresAction: 'requires_action'
} as const;

export type OrderStatusEnum = typeof OrderStatusEnum[keyof typeof OrderStatusEnum];
export const OrderFulfillmentStatusEnum = {
    NotFulfilled: 'not_fulfilled',
    PartiallyFulfilled: 'partially_fulfilled',
    Fulfilled: 'fulfilled',
    PartiallyShipped: 'partially_shipped',
    Shipped: 'shipped',
    PartiallyReturned: 'partially_returned',
    Returned: 'returned',
    Canceled: 'canceled',
    RequiresAction: 'requires_action'
} as const;

export type OrderFulfillmentStatusEnum = typeof OrderFulfillmentStatusEnum[keyof typeof OrderFulfillmentStatusEnum];
export const OrderPaymentStatusEnum = {
    NotPaid: 'not_paid',
    Awaiting: 'awaiting',
    Captured: 'captured',
    PartiallyRefunded: 'partially_refunded',
    Refuneded: 'refuneded',
    Canceled: 'canceled',
    RequiresAction: 'requires_action'
} as const;

export type OrderPaymentStatusEnum = typeof OrderPaymentStatusEnum[keyof typeof OrderPaymentStatusEnum];

/**
 * Payments represent an amount authorized with a given payment method, Payments can be captured, canceled or refunded.
 * @export
 * @interface Payment
 */
export interface Payment {
    /**
     * The id of the Payment. This value will be prefixed with `pay_`.
     * @type {string}
     * @memberof Payment
     */
    'id'?: string;
    /**
     * The id of the Swap that the Payment is used for.
     * @type {string}
     * @memberof Payment
     */
    'swap_id'?: string;
    /**
     * The id of the Order that the Payment is used for.
     * @type {string}
     * @memberof Payment
     */
    'order_id'?: string;
    /**
     * The id of the Cart that the Payment Session is created for.
     * @type {string}
     * @memberof Payment
     */
    'cart_id'?: string;
    /**
     * The amount that the Payment has been authorized for.
     * @type {number}
     * @memberof Payment
     */
    'amount'?: number;
    /**
     * The 3 character ISO currency code that the Payment is completed in.
     * @type {string}
     * @memberof Payment
     */
    'currency_code'?: string;
    /**
     * The amount of the original Payment amount that has been refunded back to the Customer.
     * @type {number}
     * @memberof Payment
     */
    'amount_refunded'?: number;
    /**
     * The id of the Payment Provider that is responsible for the Payment
     * @type {string}
     * @memberof Payment
     */
    'provider_id'?: string;
    /**
     * The data required for the Payment Provider to identify, modify and process the Payment. Typically this will be an object that holds an id to the external payment session, but can be an empty object if the Payment Provider doesn\'t hold any state.
     * @type {object}
     * @memberof Payment
     */
    'data'?: object;
    /**
     * The date with timezone at which the Payment was captured.
     * @type {string}
     * @memberof Payment
     */
    'captured_at'?: string;
    /**
     * The date with timezone at which the Payment was canceled.
     * @type {string}
     * @memberof Payment
     */
    'canceled_at'?: string;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof Payment
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof Payment
     */
    'updated_at'?: string;
    /**
     * An optional key-value map with additional information.
     * @type {object}
     * @memberof Payment
     */
    'metadata'?: object;
}
/**
 * Represents a Payment Provider plugin and holds its installation status.
 * @export
 * @interface PaymentProvider
 */
export interface PaymentProvider {
    /**
     * The id of the payment provider as given by the plugin.
     * @type {string}
     * @memberof PaymentProvider
     */
    'id'?: string;
    /**
     * Whether the plugin is installed in the current version. Plugins that are no longer installed are not deleted by will have this field set to `false`.
     * @type {boolean}
     * @memberof PaymentProvider
     */
    'is_installed'?: boolean;
}
/**
 * Payment Sessions are created when a Customer initilizes the checkout flow, and can be used to hold the state of a payment flow. Each Payment Session is controlled by a Payment Provider, who is responsible for the communication with external payment services. Authorized Payment Sessions will eventually get promoted to Payments to indicate that they are authorized for capture/refunds/etc.
 * @export
 * @interface PaymentSession
 */
export interface PaymentSession {
    /**
     * The id of the Payment Session. This value will be prefixed with `ps_`.
     * @type {string}
     * @memberof PaymentSession
     */
    'id'?: string;
    /**
     * The id of the Cart that the Payment Session is created for.
     * @type {string}
     * @memberof PaymentSession
     */
    'cart_id'?: string;
    /**
     * The id of the Payment Provider that is responsible for the Payment Session
     * @type {string}
     * @memberof PaymentSession
     */
    'provider_id'?: string;
    /**
     * A flag to indicate if the Payment Session has been selected as the method that will be used to complete the purchase.
     * @type {boolean}
     * @memberof PaymentSession
     */
    'is_selected'?: boolean;
    /**
     * Indicates the status of the Payment Session. Will default to `pending`, and will eventually become `authorized`. Payment Sessions may have the status of `requires_more` to indicate that further actions are to be completed by the Customer.
     * @type {string}
     * @memberof PaymentSession
     */
    'status'?: PaymentSessionStatusEnum;
    /**
     * The data required for the Payment Provider to identify, modify and process the Payment Session. Typically this will be an object that holds an id to the external payment session, but can be an empty object if the Payment Provider doesn\'t hold any state.
     * @type {object}
     * @memberof PaymentSession
     */
    'data'?: object;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof PaymentSession
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof PaymentSession
     */
    'updated_at'?: string;
}

export const PaymentSessionStatusEnum = {
    Authorized: 'authorized',
    Pending: 'pending',
    RequiresMore: 'requires_more',
    Error: 'error',
    Canceled: 'canceled'
} as const;

export type PaymentSessionStatusEnum = typeof PaymentSessionStatusEnum[keyof typeof PaymentSessionStatusEnum];

/**
 * Products are a grouping of Product Variants that have common properties such as images and descriptions. Products can have multiple options which define the properties that Product Variants differ by.
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * The id of the Product. This value will be prefixed with `prod_`.
     * @type {string}
     * @memberof Product
     */
    'id'?: string;
    /**
     * A title that can be displayed for easy identification of the Product.
     * @type {string}
     * @memberof Product
     */
    'title'?: string;
    /**
     * An optional subtitle that can be used to further specify the Product.
     * @type {string}
     * @memberof Product
     */
    'subtitle'?: string;
    /**
     * A short description of the Product.
     * @type {string}
     * @memberof Product
     */
    'description'?: string;
    /**
     * A unique identifier for the Product (e.g. for slug structure).
     * @type {string}
     * @memberof Product
     */
    'handle'?: string;
    /**
     * Whether the Product represents a Gift Card. Products that represent Gift Cards will automatically generate a redeemable Gift Card code once they are purchased.
     * @type {boolean}
     * @memberof Product
     */
    'is_giftcard'?: boolean;
    /**
     * Whether the Product can be discounted. Discounts will not apply to Line Items of this Product when this flag is set to `false`.
     * @type {boolean}
     * @memberof Product
     */
    'discountable'?: boolean;
    /**
     * Images of the Product
     * @type {Array<Image>}
     * @memberof Product
     */
    'images'?: Array<Image>;
    /**
     * A URL to an image file that can be used to identify the Product.
     * @type {string}
     * @memberof Product
     */
    'thumbnail'?: string;
    /**
     * The Product Options that are defined for the Product. Product Variants of the Product will have a unique combination of Product Option Values.
     * @type {Array<ProductOption>}
     * @memberof Product
     */
    'options'?: Array<ProductOption>;
    /**
     * The Product Variants that belong to the Product. Each will have a unique combination of Product Option Values.
     * @type {Array<ProductVariant>}
     * @memberof Product
     */
    'variants'?: Array<ProductVariant>;
    /**
     * The id of the Shipping Profile that the Product belongs to. Shipping Profiles have a set of defined Shipping Options that can be used to Fulfill a given set of Products.
     * @type {string}
     * @memberof Product
     */
    'profile_id'?: string;
    /**
     * The Harmonized System code of the Product Variant. May be used by Fulfillment Providers to pass customs information to shipping carriers.
     * @type {string}
     * @memberof Product
     */
    'hs_code'?: string;
    /**
     * The country in which the Product Variant was produced. May be used by Fulfillment Providers to pass customs information to shipping carriers.
     * @type {string}
     * @memberof Product
     */
    'origin_country'?: string;
    /**
     * The Manufacturers Identification code that identifies the manufacturer of the Product Variant. May be used by Fulfillment Providers to pass customs information to shipping carriers.
     * @type {string}
     * @memberof Product
     */
    'mid_code'?: string;
    /**
     * The material and composition that the Product Variant is made of, May be used by Fulfillment Providers to pass customs information to shipping carriers.
     * @type {string}
     * @memberof Product
     */
    'material'?: string;
    /**
     * The weight of the Product Variant. May be used in shipping rate calculations.
     * @type {string}
     * @memberof Product
     */
    'weight'?: string;
    /**
     * The height of the Product Variant. May be used in shipping rate calculations.
     * @type {string}
     * @memberof Product
     */
    'height'?: string;
    /**
     * The width of the Product Variant. May be used in shipping rate calculations.
     * @type {string}
     * @memberof Product
     */
    'width'?: string;
    /**
     * The length of the Product Variant. May be used in shipping rate calculations.
     * @type {string}
     * @memberof Product
     */
    'length'?: string;
    /**
     * The Product Type of the Product (e.g. \"Clothing\")
     * @type {ProductType}
     * @memberof Product
     */
    'type'?: ProductType;
    /**
     * The Product Collection that the Product belongs to (e.g. \"SS20\")
     * @type {ProductCollection}
     * @memberof Product
     */
    'collection'?: ProductCollection;
    /**
     * The Product Tags assigned to the Product.
     * @type {Array<ProductTag>}
     * @memberof Product
     */
    'tags'?: Array<ProductTag>;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof Product
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof Product
     */
    'updated_at'?: string;
    /**
     * The date with timezone at which the resource was deleted.
     * @type {string}
     * @memberof Product
     */
    'deleted_at'?: string;
    /**
     * An optional key-value map with additional information.
     * @type {object}
     * @memberof Product
     */
    'metadata'?: object;
}
/**
 * Product Collections represents a group of Products that are related.
 * @export
 * @interface ProductCollection
 */
export interface ProductCollection {
    /**
     * The id of the Product Collection. This value will be prefixed with `pcol_`.
     * @type {string}
     * @memberof ProductCollection
     */
    'id'?: string;
    /**
     * The title that the Product Collection is identified by.
     * @type {string}
     * @memberof ProductCollection
     */
    'title'?: string;
    /**
     * A unique string that identifies the Product Collection - can for example be used in slug structures.
     * @type {string}
     * @memberof ProductCollection
     */
    'handle'?: string;
    /**
     * The Products contained in the Product Collection.
     * @type {Array<Product>}
     * @memberof ProductCollection
     */
    'products'?: Array<Product>;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof ProductCollection
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof ProductCollection
     */
    'updated_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof ProductCollection
     */
    'deleted_at'?: string;
    /**
     * An optional key-value map with additional information.
     * @type {object}
     * @memberof ProductCollection
     */
    'metadata'?: object;
}
/**
 * Product Options define properties that may vary between different variants of a Product. Common Product Options are \"Size\" and \"Color\", but Medusa doesn\'t limit what Product Options that can be defined.
 * @export
 * @interface ProductOption
 */
export interface ProductOption {
    /**
     * The id of the Product Option. This value will be prefixed with `opt_`.
     * @type {string}
     * @memberof ProductOption
     */
    'id'?: string;
    /**
     * The title that the Product Option is defined by (e.g. \"Size\").
     * @type {string}
     * @memberof ProductOption
     */
    'title'?: string;
    /**
     * The Product Option Values that are defined for the Product Option.
     * @type {Array<ProductOptionValue>}
     * @memberof ProductOption
     */
    'values'?: Array<ProductOptionValue>;
    /**
     * The id of the Product that the Product Option is defined for.
     * @type {string}
     * @memberof ProductOption
     */
    'product_id'?: string;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof ProductOption
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof ProductOption
     */
    'updated_at'?: string;
    /**
     * The date with timezone at which the resource was deleted.
     * @type {string}
     * @memberof ProductOption
     */
    'deleted_at'?: string;
    /**
     * An optional key-value map with additional information.
     * @type {object}
     * @memberof ProductOption
     */
    'metadata'?: object;
}
/**
 * A value given to a Product Variant\'s option set. Product Variant have a Product Option Value for each of the Product Options defined on the Product.
 * @export
 * @interface ProductOptionValue
 */
export interface ProductOptionValue {
    /**
     * The id of the Product Option Value. This value will be prefixed with `optval_`.
     * @type {string}
     * @memberof ProductOptionValue
     */
    'id'?: string;
    /**
     * The value that the Product Variant has defined for the specific Product Option (e.g. if the Product Option is \"Size\" this value could be \"Small\", \"Medium\" or \"Large\").
     * @type {string}
     * @memberof ProductOptionValue
     */
    'value'?: string;
    /**
     * The id of the Product Option that the Product Option Value is defined for.
     * @type {string}
     * @memberof ProductOptionValue
     */
    'option_id'?: string;
    /**
     * The id of the Product Variant that the Product Option Value is defined for.
     * @type {string}
     * @memberof ProductOptionValue
     */
    'variant_id'?: string;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof ProductOptionValue
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof ProductOptionValue
     */
    'updated_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof ProductOptionValue
     */
    'deleted_at'?: string;
    /**
     * An optional key-value map with additional information.
     * @type {object}
     * @memberof ProductOptionValue
     */
    'metadata'?: object;
}
/**
 * Product Tags can be added to Products for easy filtering and grouping.
 * @export
 * @interface ProductTag
 */
export interface ProductTag {
    /**
     * The id of the Product Tag. This value will be prefixed with `ptag_`.
     * @type {string}
     * @memberof ProductTag
     */
    'id'?: string;
    /**
     * The value that the Product Tag represents (e.g. \"Pants\").
     * @type {string}
     * @memberof ProductTag
     */
    'value'?: string;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof ProductTag
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof ProductTag
     */
    'updated_at'?: string;
    /**
     * The date with timezone at which the resource was deleted.
     * @type {string}
     * @memberof ProductTag
     */
    'deleted_at'?: string;
    /**
     * An optional key-value map with additional information.
     * @type {object}
     * @memberof ProductTag
     */
    'metadata'?: object;
}
/**
 * Associates a tax rate with a product to indicate that the product is taxed in a certain way
 * @export
 * @interface ProductTaxRate
 */
export interface ProductTaxRate {
    /**
     * The id of the Product
     * @type {string}
     * @memberof ProductTaxRate
     */
    'product_id'?: string;
    /**
     * The id of the Tax Rate
     * @type {string}
     * @memberof ProductTaxRate
     */
    'rate_id'?: string;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof ProductTaxRate
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof ProductTaxRate
     */
    'updated_at'?: string;
    /**
     * The date with timezone at which the resource was deleted.
     * @type {string}
     * @memberof ProductTaxRate
     */
    'deleted_at'?: string;
    /**
     * An optional key-value map with additional information.
     * @type {object}
     * @memberof ProductTaxRate
     */
    'metadata'?: object;
}
/**
 * Product Type can be added to Products for filtering and reporting purposes.
 * @export
 * @interface ProductType
 */
export interface ProductType {
    /**
     * The id of the Product Type. This value will be prefixed with `ptyp_`.
     * @type {string}
     * @memberof ProductType
     */
    'id'?: string;
    /**
     * The value that the Product Type represents (e.g. \"Clothing\").
     * @type {string}
     * @memberof ProductType
     */
    'value'?: string;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof ProductType
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof ProductType
     */
    'updated_at'?: string;
    /**
     * The date with timezone at which the resource was deleted.
     * @type {string}
     * @memberof ProductType
     */
    'deleted_at'?: string;
    /**
     * An optional key-value map with additional information.
     * @type {object}
     * @memberof ProductType
     */
    'metadata'?: object;
}
/**
 * Associates a tax rate with a product type to indicate that the product type is taxed in a certain way
 * @export
 * @interface ProductTypeTaxRate
 */
export interface ProductTypeTaxRate {
    /**
     * The id of the Product type
     * @type {string}
     * @memberof ProductTypeTaxRate
     */
    'product_type_id'?: string;
    /**
     * The id of the Tax Rate
     * @type {string}
     * @memberof ProductTypeTaxRate
     */
    'rate_id'?: string;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof ProductTypeTaxRate
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof ProductTypeTaxRate
     */
    'updated_at'?: string;
    /**
     * The date with timezone at which the resource was deleted.
     * @type {string}
     * @memberof ProductTypeTaxRate
     */
    'deleted_at'?: string;
    /**
     * An optional key-value map with additional information.
     * @type {object}
     * @memberof ProductTypeTaxRate
     */
    'metadata'?: object;
}
/**
 * Product Variants represent a Product with a specific set of Product Option configurations. The maximum number of Product Variants that a Product can have is given by the number of available Product Option combinations.
 * @export
 * @interface ProductVariant
 */
export interface ProductVariant {
    /**
     * The id of the Product Variant. This value will be prefixed with `variant_`.
     * @type {string}
     * @memberof ProductVariant
     */
    'id'?: string;
    /**
     * A title that can be displayed for easy identification of the Product Variant.
     * @type {string}
     * @memberof ProductVariant
     */
    'title'?: string;
    /**
     * The id of the Product that the Product Variant belongs to.
     * @type {string}
     * @memberof ProductVariant
     */
    'product_id'?: string;
    /**
     * The Money Amounts defined for the Product Variant. Each Money Amount represents a price in a given currency or a price in a specific Region.
     * @type {Array<MoneyAmount>}
     * @memberof ProductVariant
     */
    'prices'?: Array<MoneyAmount>;
    /**
     * The unique stock keeping unit used to identify the Product Variant. This will usually be a unqiue identifer for the item that is to be shipped, and can be referenced across multiple systems.
     * @type {string}
     * @memberof ProductVariant
     */
    'sku'?: string;
    /**
     * A generic field for a GTIN number that can be used to identify the Product Variant.
     * @type {string}
     * @memberof ProductVariant
     */
    'barcode'?: string;
    /**
     * An EAN barcode number that can be used to identify the Product Variant.
     * @type {string}
     * @memberof ProductVariant
     */
    'ean'?: string;
    /**
     * A UPC barcode number that can be used to identify the Product Variant.
     * @type {string}
     * @memberof ProductVariant
     */
    'upc'?: string;
    /**
     * The current quantity of the item that is stocked.
     * @type {number}
     * @memberof ProductVariant
     */
    'inventory_quantity'?: number;
    /**
     * Whether the Product Variant should be purchasable when `inventory_quantity` is 0.
     * @type {boolean}
     * @memberof ProductVariant
     */
    'allow_backorder'?: boolean;
    /**
     * Whether Medusa should manage inventory for the Product Variant.
     * @type {boolean}
     * @memberof ProductVariant
     */
    'manage_inventory'?: boolean;
    /**
     * The Harmonized System code of the Product Variant. May be used by Fulfillment Providers to pass customs information to shipping carriers.
     * @type {string}
     * @memberof ProductVariant
     */
    'hs_code'?: string;
    /**
     * The country in which the Product Variant was produced. May be used by Fulfillment Providers to pass customs information to shipping carriers.
     * @type {string}
     * @memberof ProductVariant
     */
    'origin_country'?: string;
    /**
     * The Manufacturers Identification code that identifies the manufacturer of the Product Variant. May be used by Fulfillment Providers to pass customs information to shipping carriers.
     * @type {string}
     * @memberof ProductVariant
     */
    'mid_code'?: string;
    /**
     * The material and composition that the Product Variant is made of, May be used by Fulfillment Providers to pass customs information to shipping carriers.
     * @type {string}
     * @memberof ProductVariant
     */
    'material'?: string;
    /**
     * The weight of the Product Variant. May be used in shipping rate calculations.
     * @type {string}
     * @memberof ProductVariant
     */
    'weight'?: string;
    /**
     * The height of the Product Variant. May be used in shipping rate calculations.
     * @type {string}
     * @memberof ProductVariant
     */
    'height'?: string;
    /**
     * The width of the Product Variant. May be used in shipping rate calculations.
     * @type {string}
     * @memberof ProductVariant
     */
    'width'?: string;
    /**
     * The length of the Product Variant. May be used in shipping rate calculations.
     * @type {string}
     * @memberof ProductVariant
     */
    'length'?: string;
    /**
     * The Product Option Values specified for the Product Variant.
     * @type {Array<ProductOptionValue>}
     * @memberof ProductVariant
     */
    'options'?: Array<ProductOptionValue>;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof ProductVariant
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof ProductVariant
     */
    'updated_at'?: string;
    /**
     * The date with timezone at which the resource was deleted.
     * @type {string}
     * @memberof ProductVariant
     */
    'deleted_at'?: string;
    /**
     * An optional key-value map with additional information.
     * @type {object}
     * @memberof ProductVariant
     */
    'metadata'?: object;
}
/**
 * Refund represent an amount of money transfered back to the Customer for a given reason. Refunds may occur in relation to Returns, Swaps and Claims, but can also be initiated by a store operator.
 * @export
 * @interface Refund
 */
export interface Refund {
    /**
     * The id of the Refund. This value will be prefixed with `ref_`.
     * @type {string}
     * @memberof Refund
     */
    'id'?: string;
    /**
     * The id of the Order that the Refund is related to.
     * @type {string}
     * @memberof Refund
     */
    'order_id'?: string;
    /**
     * The amount that has be refunded to the Customer.
     * @type {number}
     * @memberof Refund
     */
    'amount'?: number;
    /**
     * An optional note explaining why the amount was refunded.
     * @type {string}
     * @memberof Refund
     */
    'note'?: string;
    /**
     * The reason given for the Refund, will automatically be set when processed as part of a Swap, Claim or Return.
     * @type {string}
     * @memberof Refund
     */
    'reason'?: RefundReasonEnum;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof Refund
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof Refund
     */
    'updated_at'?: string;
    /**
     * An optional key-value map with additional information.
     * @type {object}
     * @memberof Refund
     */
    'metadata'?: object;
}

export const RefundReasonEnum = {
    Discount: 'discount',
    Return: 'return',
    Swap: 'swap',
    Claim: 'claim',
    Other: 'other'
} as const;

export type RefundReasonEnum = typeof RefundReasonEnum[keyof typeof RefundReasonEnum];

/**
 * Regions hold settings for how Customers in a given geographical location shop. The is, for example, where currencies and tax rates are defined. A Region can consist of multiple countries to accomodate common shopping settings across countries.
 * @export
 * @interface Region
 */
export interface Region {
    /**
     * The id of the Region. This value will be prefixed with `reg_`.
     * @type {string}
     * @memberof Region
     */
    'id'?: string;
    /**
     * The name of the region as displayed to the customer. If the Region only has one country it is recommended to write the country name.
     * @type {string}
     * @memberof Region
     */
    'name'?: string;
    /**
     * The 3 character ISO currency code that Customers will shop in in the Region.
     * @type {string}
     * @memberof Region
     */
    'currency_code'?: string;
    /**
     * The tax rate that should be charged on purchases in the Region.
     * @type {number}
     * @memberof Region
     */
    'tax_rate'?: number;
    /**
     * The tax code used on purchases in the Region. This may be used by other systems for accounting purposes.
     * @type {string}
     * @memberof Region
     */
    'tax_code'?: string;
    /**
     * The countries that are included in the Region.
     * @type {Array<Country>}
     * @memberof Region
     */
    'countries'?: Array<Country>;
    /**
     * The Payment Providers that can be used to process Payments in the Region.
     * @type {Array<PaymentProvider>}
     * @memberof Region
     */
    'payment_providers'?: Array<PaymentProvider>;
    /**
     * The Fulfillment Providers that can be used to fulfill orders in the Region.
     * @type {Array<FulfillmentProvider>}
     * @memberof Region
     */
    'fulfillment_providers'?: Array<FulfillmentProvider>;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof Region
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof Region
     */
    'updated_at'?: string;
    /**
     * The date with timezone at which the resource was deleted.
     * @type {string}
     * @memberof Region
     */
    'deleted_at'?: string;
    /**
     * An optional key-value map with additional information.
     * @type {object}
     * @memberof Region
     */
    'metadata'?: object;
}
/**
 * Return orders hold information about Line Items that a Customer wishes to send back, along with how the items will be returned. Returns can be used as part of a Swap.
 * @export
 * @interface Return
 */
export interface Return {
    /**
     * The id of the Return. This value will be prefixed with `ret_`.
     * @type {string}
     * @memberof Return
     */
    'id'?: string;
    /**
     * Status of the Return.
     * @type {string}
     * @memberof Return
     */
    'status'?: ReturnStatusEnum;
    /**
     * The Return Items that will be shipped back to the warehouse. type: array items: $ref:
     * @type {any}
     * @memberof Return
     */
    'items'?: any;
    /**
     * The id of the Swap that the Return is a part of.
     * @type {string}
     * @memberof Return
     */
    'swap_id'?: string;
    /**
     * The id of the Order that the Return is made from.
     * @type {string}
     * @memberof Return
     */
    'order_id'?: string;
    /**
     * The id of the Claim that the Return is a part of.
     * @type {string}
     * @memberof Return
     */
    'claim_order_id'?: string;
    /**
     * The Shipping Method that will be used to send the Return back. Can be null if the Customer facilitates the return shipment themselves.
     * @type {ShippingMethod}
     * @memberof Return
     */
    'shipping_method'?: ShippingMethod;
    /**
     * Data about the return shipment as provided by the Fulfilment Provider that handles the return shipment.
     * @type {object}
     * @memberof Return
     */
    'shipping_data'?: object;
    /**
     * The amount that should be refunded as a result of the return.
     * @type {number}
     * @memberof Return
     */
    'refund_amount'?: number;
    /**
     * The date with timezone at which the return was received.
     * @type {string}
     * @memberof Return
     */
    'received_at'?: string;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof Return
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof Return
     */
    'updated_at'?: string;
    /**
     * When set to true, no notification will be sent related to this return.
     * @type {boolean}
     * @memberof Return
     */
    'no_notification'?: boolean;
    /**
     * An optional key-value map with additional information.
     * @type {object}
     * @memberof Return
     */
    'metadata'?: object;
}

export const ReturnStatusEnum = {
    Requested: 'requested',
    Received: 'received',
    RequiresAction: 'requires_action'
} as const;

export type ReturnStatusEnum = typeof ReturnStatusEnum[keyof typeof ReturnStatusEnum];

/**
 * Correlates a Line Item with a Return, keeping track of the quantity of the Line Item that will be returned.
 * @export
 * @interface ReturnItem
 */
export interface ReturnItem {
    /**
     * The id of the Return that the Return Item belongs to.
     * @type {string}
     * @memberof ReturnItem
     */
    'return_id'?: string;
    /**
     * The id of the Line Item that the Return Item references.
     * @type {string}
     * @memberof ReturnItem
     */
    'item_id'?: string;
    /**
     * The Line Item that the Return Item references.
     * @type {LineItem}
     * @memberof ReturnItem
     */
    'item'?: LineItem;
    /**
     * The quantity of the Line Item that is included in the Return.
     * @type {number}
     * @memberof ReturnItem
     */
    'quantity'?: number;
    /**
     * Whether the Return Item was requested initially or received unexpectedly in the warehouse.
     * @type {boolean}
     * @memberof ReturnItem
     */
    'is_requested'?: boolean;
    /**
     * The quantity that was originally requested to be returned.
     * @type {number}
     * @memberof ReturnItem
     */
    'requested_quantity'?: number;
    /**
     * The quantity that was received in the warehouse.
     * @type {number}
     * @memberof ReturnItem
     */
    'recieved_quantity'?: number;
    /**
     * The reason for returning the item.
     * @type {ReturnReason}
     * @memberof ReturnItem
     */
    'reason'?: ReturnReason;
    /**
     * An optional note with additional details about the Return.
     * @type {string}
     * @memberof ReturnItem
     */
    'note'?: string;
    /**
     * An optional key-value map with additional information.
     * @type {object}
     * @memberof ReturnItem
     */
    'metadata'?: object;
}
/**
 * A Reason for why a given product is returned. A Return Reason can be used on Return Items in order to indicate why a Line Item was returned.
 * @export
 * @interface ReturnReason
 */
export interface ReturnReason {
    /**
     * The id of the Return Reason will start with `rr_`.
     * @type {string}
     * @memberof ReturnReason
     */
    'id'?: string;
    /**
     * A description of the Reason.
     * @type {string}
     * @memberof ReturnReason
     */
    'description'?: string;
    /**
     * A text that can be displayed to the Customer as a reason.
     * @type {string}
     * @memberof ReturnReason
     */
    'label'?: string;
    /**
     * The value to identify the reason by.
     * @type {string}
     * @memberof ReturnReason
     */
    'value'?: string;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof ReturnReason
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof ReturnReason
     */
    'updated_at'?: string;
    /**
     * The date with timezone at which the resource was deleted.
     * @type {string}
     * @memberof ReturnReason
     */
    'deleted_at'?: string;
    /**
     * An optional key-value map with additional information.
     * @type {object}
     * @memberof ReturnReason
     */
    'metadata'?: object;
}
/**
 * Shipping Methods represent a way in which an Order or Return can be shipped. Shipping Methods are built from a Shipping Option, but may contain additional details, that can be necessary for the Fulfillment Provider to handle the shipment.
 * @export
 * @interface ShippingMethod
 */
export interface ShippingMethod {
    /**
     * The id of the Shipping Method. This value will be prefixed with `sm_`.
     * @type {string}
     * @memberof ShippingMethod
     */
    'id'?: string;
    /**
     * The id of the Shipping Option that the Shipping Method is built from.
     * @type {string}
     * @memberof ShippingMethod
     */
    'shipping_option_id'?: string;
    /**
     * The Shipping Option that the Shipping Method is built from.
     * @type {ShippingOption}
     * @memberof ShippingMethod
     */
    'shipping_option'?: ShippingOption;
    /**
     * The id of the Order that the Shipping Method is used on.
     * @type {string}
     * @memberof ShippingMethod
     */
    'order_id'?: string;
    /**
     * The id of the Return that the Shipping Method is used on.
     * @type {string}
     * @memberof ShippingMethod
     */
    'return_id'?: string;
    /**
     * The id of the Swap that the Shipping Method is used on.
     * @type {string}
     * @memberof ShippingMethod
     */
    'swap_id'?: string;
    /**
     * The id of the Cart that the Shipping Method is used on.
     * @type {string}
     * @memberof ShippingMethod
     */
    'cart_id'?: string;
    /**
     * The id of the Claim that the Shipping Method is used on.
     * @type {string}
     * @memberof ShippingMethod
     */
    'claim_order_id'?: string;
    /**
     * The amount to charge for the Shipping Method. The currency of the price is defined by the Region that the Order that the Shipping Method belongs to is a part of.
     * @type {number}
     * @memberof ShippingMethod
     */
    'price'?: number;
    /**
     * Additional data that the Fulfillment Provider needs to fulfill the shipment. This is used in combination with the Shipping Options data, and may contain information such as a drop point id.
     * @type {object}
     * @memberof ShippingMethod
     */
    'data'?: object;
}
/**
 * Shipping Options represent a way in which an Order or Return can be shipped. Shipping Options have an associated Fulfillment Provider that will be used when the fulfillment of an Order is initiated. Shipping Options themselves cannot be added to Carts, but serve as a template for Shipping Methods. This distinction makes it possible to customize individual Shipping Methods with additional information.
 * @export
 * @interface ShippingOption
 */
export interface ShippingOption {
    /**
     * The id of the Shipping Option. This value will be prefixed with `so_`.
     * @type {string}
     * @memberof ShippingOption
     */
    'id'?: string;
    /**
     * The name given to the Shipping Option - this may be displayed to the Customer.
     * @type {string}
     * @memberof ShippingOption
     */
    'name'?: string;
    /**
     * The id of the Region that the Shipping Option belongs to.
     * @type {string}
     * @memberof ShippingOption
     */
    'region_id'?: string;
    /**
     * The id of the Region that the Shipping Option belongs to.
     * @type {Region}
     * @memberof ShippingOption
     */
    'region'?: Region;
    /**
     * The id of the Shipping Profile that the Shipping Option belongs to. Shipping Profiles have a set of defined Shipping Options that can be used to Fulfill a given set of Products.
     * @type {string}
     * @memberof ShippingOption
     */
    'profile_id'?: string;
    /**
     * The id of the Fulfillment Provider, that will be used to process Fulfillments from the Shipping Option.
     * @type {string}
     * @memberof ShippingOption
     */
    'provider_id'?: string;
    /**
     * The type of pricing calculation that is used when creatin Shipping Methods from the Shipping Option. Can be `flat_rate` for fixed prices or `calculated` if the Fulfillment Provider can provide price calulations.
     * @type {string}
     * @memberof ShippingOption
     */
    'price_type'?: ShippingOptionPriceTypeEnum;
    /**
     * The amount to charge for shipping when the Shipping Option price type is `flat_rate`.
     * @type {number}
     * @memberof ShippingOption
     */
    'amount'?: number;
    /**
     * Flag to indicate if the Shipping Option can be used for Return shipments.
     * @type {boolean}
     * @memberof ShippingOption
     */
    'is_return'?: boolean;
    /**
     * The requirements that must be satisfied for the Shipping Option to be available for a Cart.
     * @type {Array<ShippingOptionRequirement>}
     * @memberof ShippingOption
     */
    'requirements'?: Array<ShippingOptionRequirement>;
    /**
     * The data needed for the Fulfillment Provider to identify the Shipping Option.
     * @type {object}
     * @memberof ShippingOption
     */
    'data'?: object;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof ShippingOption
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof ShippingOption
     */
    'updated_at'?: string;
    /**
     * The date with timezone at which the resource was deleted.
     * @type {string}
     * @memberof ShippingOption
     */
    'deleted_at'?: string;
    /**
     * An optional key-value map with additional information.
     * @type {object}
     * @memberof ShippingOption
     */
    'metadata'?: object;
}

export const ShippingOptionPriceTypeEnum = {
    FlatRate: 'flat_rate',
    Calculated: 'calculated'
} as const;

export type ShippingOptionPriceTypeEnum = typeof ShippingOptionPriceTypeEnum[keyof typeof ShippingOptionPriceTypeEnum];

/**
 * A requirement that a Cart must satisfy for the Shipping Option to be available to the Cart.
 * @export
 * @interface ShippingOptionRequirement
 */
export interface ShippingOptionRequirement {
    /**
     * The id of the Shipping Option Requirement. This value will be prefixed with `sor_`.
     * @type {string}
     * @memberof ShippingOptionRequirement
     */
    'id'?: string;
    /**
     * The id of the Shipping Option that the Shipping Option Requirement belongs to.
     * @type {string}
     * @memberof ShippingOptionRequirement
     */
    'shipping_option_id'?: string;
    /**
     * The type of the requirement, this defines how the value will be compared to the Cart\'s total. `min_subtotal` requirements define the minimum subtotal that is needed for the Shipping Option to be available, while the `max_subtotal` defines the maximum subtotal that the Cart can have for the Shipping Option to be available.
     * @type {string}
     * @memberof ShippingOptionRequirement
     */
    'type'?: ShippingOptionRequirementTypeEnum;
    /**
     * The amount to compare the Cart subtotal to.
     * @type {number}
     * @memberof ShippingOptionRequirement
     */
    'amount'?: number;
}

export const ShippingOptionRequirementTypeEnum = {
    MinSubtotal: 'min_subtotal',
    MaxSubtotal: 'max_subtotal'
} as const;

export type ShippingOptionRequirementTypeEnum = typeof ShippingOptionRequirementTypeEnum[keyof typeof ShippingOptionRequirementTypeEnum];

/**
 * Shipping Profiles have a set of defined Shipping Options that can be used to fulfill a given set of Products.
 * @export
 * @interface ShippingProfile
 */
export interface ShippingProfile {
    /**
     * The id of the Shipping Profile. This value will be prefixed with `sp_`.
     * @type {string}
     * @memberof ShippingProfile
     */
    'id'?: string;
    /**
     * The name given to the Shipping profile - this may be displayed to the Customer.
     * @type {string}
     * @memberof ShippingProfile
     */
    'name'?: string;
    /**
     * The type of the Shipping Profile, may be `default`, `gift_card` or `custom`.
     * @type {string}
     * @memberof ShippingProfile
     */
    'type'?: ShippingProfileTypeEnum;
    /**
     * The Products that the Shipping Profile defines Shipping Options for.
     * @type {Array<Product>}
     * @memberof ShippingProfile
     */
    'products'?: Array<Product>;
    /**
     * The Shipping Options that can be used to fulfill the Products in the Shipping Profile.
     * @type {Array<ShippingOption>}
     * @memberof ShippingProfile
     */
    'shipping_options'?: Array<ShippingOption>;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof ShippingProfile
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof ShippingProfile
     */
    'updated_at'?: string;
    /**
     * The date with timezone at which the resource was deleted.
     * @type {string}
     * @memberof ShippingProfile
     */
    'deleted_at'?: string;
    /**
     * An optional key-value map with additional information.
     * @type {object}
     * @memberof ShippingProfile
     */
    'metadata'?: object;
}

export const ShippingProfileTypeEnum = {
    Default: 'default',
    GiftCard: 'gift_card',
    Custom: 'custom'
} as const;

export type ShippingProfileTypeEnum = typeof ShippingProfileTypeEnum[keyof typeof ShippingProfileTypeEnum];

/**
 * Associates a tax rate with a shipping option to indicate that the shipping option is taxed in a certain way
 * @export
 * @interface ShippingTaxRate
 */
export interface ShippingTaxRate {
    /**
     * The id of the Shipping Option
     * @type {string}
     * @memberof ShippingTaxRate
     */
    'shipping_option_id'?: string;
    /**
     * The id of the Tax Rate
     * @type {string}
     * @memberof ShippingTaxRate
     */
    'rate_id'?: string;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof ShippingTaxRate
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof ShippingTaxRate
     */
    'updated_at'?: string;
    /**
     * The date with timezone at which the resource was deleted.
     * @type {string}
     * @memberof ShippingTaxRate
     */
    'deleted_at'?: string;
    /**
     * An optional key-value map with additional information.
     * @type {object}
     * @memberof ShippingTaxRate
     */
    'metadata'?: object;
}
/**
 * Holds settings for the Store, such as name, currencies, etc.
 * @export
 * @interface Store
 */
export interface Store {
    /**
     * The id of the Store. This value will be prefixed with `store_`.
     * @type {string}
     * @memberof Store
     */
    'id'?: string;
    /**
     * The name of the Store - this may be displayed to the Customer.
     * @type {string}
     * @memberof Store
     */
    'name'?: string;
    /**
     * The default currency code used when no other currency code is specified.
     * @type {string}
     * @memberof Store
     */
    'default_currency_code'?: string;
    /**
     * The currencies that are enabled for the Store.
     * @type {Array<Currency>}
     * @memberof Store
     */
    'currencies'?: Array<Currency>;
    /**
     * A template to generate Swap links from use {{cart_id}} to include the Swap\'s `cart_id` in the link.
     * @type {string}
     * @memberof Store
     */
    'swap_link_template'?: string;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof Store
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof Store
     */
    'updated_at'?: string;
    /**
     * An optional key-value map with additional information.
     * @type {object}
     * @memberof Store
     */
    'metadata'?: object;
}
/**
 * Swaps can be created when a Customer wishes to exchange Products that they have purchased to different Products. Swaps consist of a Return of previously purchased Products and a Fulfillment of new Products, the amount paid for the Products being returned will be used towards payment for the new Products. In the case where the amount paid for the the Products being returned exceed the amount to be paid for the new Products, a Refund will be issued for the difference.
 * @export
 * @interface Swap
 */
export interface Swap {
    /**
     * The id of the Swap. This value will be prefixed with `swap_`.
     * @type {string}
     * @memberof Swap
     */
    'id'?: string;
    /**
     * The status of the Fulfillment of the Swap.
     * @type {string}
     * @memberof Swap
     */
    'fulfillment_status'?: SwapFulfillmentStatusEnum;
    /**
     * The status of the Payment of the Swap. The payment may either refer to the refund of an amount or the authorization of a new amount.
     * @type {string}
     * @memberof Swap
     */
    'payment_status'?: SwapPaymentStatusEnum;
    /**
     * The id of the Order where the Line Items to be returned where purchased.
     * @type {string}
     * @memberof Swap
     */
    'order_id'?: string;
    /**
     * The new Line Items to ship to the Customer.
     * @type {Array<LineItem>}
     * @memberof Swap
     */
    'additional_items'?: Array<LineItem>;
    /**
     * The Return that is issued for the return part of the Swap.
     * @type {Return}
     * @memberof Swap
     */
    'return_order'?: Return;
    /**
     * The Fulfillments used to send the new Line Items.
     * @type {Array<Fulfillment>}
     * @memberof Swap
     */
    'fulfillments'?: Array<Fulfillment>;
    /**
     * The Payment authorized when the Swap requires an additional amount to be charged from the Customer.
     * @type {Payment}
     * @memberof Swap
     */
    'payment'?: Payment;
    /**
     * The difference that is paid or refunded as a result of the Swap. May be negative when the amount paid for the returned items exceed the total of the new Products.
     * @type {number}
     * @memberof Swap
     */
    'difference_due'?: number;
    /**
     * The Address to send the new Line Items to - in most cases this will be the same as the shipping address on the Order.
     * @type {Address}
     * @memberof Swap
     */
    'shipping_address'?: Address;
    /**
     * The Shipping Methods used to fulfill the addtional items purchased.
     * @type {Array<ShippingMethod>}
     * @memberof Swap
     */
    'shipping_methods'?: Array<ShippingMethod>;
    /**
     * The id of the Cart that the Customer will use to confirm the Swap.
     * @type {string}
     * @memberof Swap
     */
    'cart_id'?: string;
    /**
     * If true, swaps can be completed with items out of stock
     * @type {boolean}
     * @memberof Swap
     */
    'allow_backorder'?: boolean;
    /**
     * The date with timezone at which the Swap was confirmed by the Customer.
     * @type {string}
     * @memberof Swap
     */
    'confirmed_at'?: string;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof Swap
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof Swap
     */
    'updated_at'?: string;
    /**
     * The date with timezone at which the Swap was canceled.
     * @type {string}
     * @memberof Swap
     */
    'canceled_at'?: string;
    /**
     * If set to true, no notification will be sent related to this swap
     * @type {boolean}
     * @memberof Swap
     */
    'no_notification'?: boolean;
    /**
     * An optional key-value map with additional information.
     * @type {object}
     * @memberof Swap
     */
    'metadata'?: object;
}

export const SwapFulfillmentStatusEnum = {
    NotFulfilled: 'not_fulfilled',
    PartiallyFulfilled: 'partially_fulfilled',
    Fulfilled: 'fulfilled',
    PartiallyShipped: 'partially_shipped',
    Shipped: 'shipped',
    PartiallyReturned: 'partially_returned',
    Returned: 'returned',
    Canceled: 'canceled',
    RequiresAction: 'requires_action'
} as const;

export type SwapFulfillmentStatusEnum = typeof SwapFulfillmentStatusEnum[keyof typeof SwapFulfillmentStatusEnum];
export const SwapPaymentStatusEnum = {
    NotPaid: 'not_paid',
    Awaiting: 'awaiting',
    Captured: 'captured',
    Canceled: 'canceled',
    DifferenceRefunded: 'difference_refunded',
    RequiresAction: 'requires_action'
} as const;

export type SwapPaymentStatusEnum = typeof SwapPaymentStatusEnum[keyof typeof SwapPaymentStatusEnum];

/**
 * Line item that specifies an amount of tax to add to a line item.
 * @export
 * @interface TaxLine
 */
export interface TaxLine {
    /**
     * The id of the Tax Line. This value will be prefixed by `tl_`.
     * @type {string}
     * @memberof TaxLine
     */
    'id'?: string;
    /**
     * A code to identify the tax type by
     * @type {string}
     * @memberof TaxLine
     */
    'code'?: string;
    /**
     * A human friendly name for the tax
     * @type {string}
     * @memberof TaxLine
     */
    'name'?: string;
    /**
     * The numeric rate to charge tax by
     * @type {number}
     * @memberof TaxLine
     */
    'rate'?: number;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof TaxLine
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof TaxLine
     */
    'updated_at'?: string;
    /**
     * An optional key-value map with additional information.
     * @type {object}
     * @memberof TaxLine
     */
    'metadata'?: object;
}
/**
 * The tax service used to calculate taxes
 * @export
 * @interface TaxProvider
 */
export interface TaxProvider {
    /**
     * The id of the tax provider as given by the plugin.
     * @type {string}
     * @memberof TaxProvider
     */
    'id'?: string;
    /**
     * Whether the plugin is installed in the current version. Plugins that are no longer installed are not deleted by will have this field set to `false`.
     * @type {boolean}
     * @memberof TaxProvider
     */
    'is_installed'?: boolean;
}
/**
 * A Tax Rate can be used to associate a certain rate to charge on products within a given Region
 * @export
 * @interface TaxRate
 */
export interface TaxRate {
    /**
     * The id of the Tax Rate. This value will be prefixed by `txr_`.
     * @type {string}
     * @memberof TaxRate
     */
    'id'?: string;
    /**
     * The numeric rate to charge
     * @type {number}
     * @memberof TaxRate
     */
    'rate'?: number;
    /**
     * A code to identify the tax type by
     * @type {string}
     * @memberof TaxRate
     */
    'code'?: string;
    /**
     * A human friendly name for the tax
     * @type {string}
     * @memberof TaxRate
     */
    'name'?: string;
    /**
     * The id of the Region that the rate belongs to
     * @type {string}
     * @memberof TaxRate
     */
    'region_id'?: string;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof TaxRate
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof TaxRate
     */
    'updated_at'?: string;
    /**
     * An optional key-value map with additional information.
     * @type {object}
     * @memberof TaxRate
     */
    'metadata'?: object;
    /**
     * The amount that can be refunded from the given Line Item. Takes taxes and discounts into consideration.
     * @type {number}
     * @memberof TaxRate
     */
    'refundable'?: number;
}
/**
 * Tracking Link holds information about tracking numbers for a Fulfillment. Tracking Links can optionally contain a URL that can be visited to see the status of the shipment.
 * @export
 * @interface TrackingLink
 */
export interface TrackingLink {
    /**
     * The id of the Tracking Link. This value will be prefixed with `tlink_`.
     * @type {string}
     * @memberof TrackingLink
     */
    'id'?: string;
    /**
     * The URL at which the status of the shipment can be tracked.
     * @type {string}
     * @memberof TrackingLink
     */
    'url'?: string;
    /**
     * The tracking number given by the shipping carrier.
     * @type {string}
     * @memberof TrackingLink
     */
    'tracking_number'?: string;
    /**
     * The id of the Fulfillment that the Tracking Link references.
     * @type {string}
     * @memberof TrackingLink
     */
    'fulfillment_id'?: string;
    /**
     * The date with timezone at which the resource was created.
     * @type {string}
     * @memberof TrackingLink
     */
    'created_at'?: string;
    /**
     * The date with timezone at which the resource was last updated.
     * @type {string}
     * @memberof TrackingLink
     */
    'updated_at'?: string;
    /**
     * The date with timezone at which the resource was deleted.
     * @type {string}
     * @memberof TrackingLink
     */
    'deleted_at'?: string;
    /**
     * An optional key-value map with additional information.
     * @type {object}
     * @memberof TrackingLink
     */
    'metadata'?: object;
}
/**
 * Represents a User who can manage store settings.
 * @export
 * @interface User
 */
export interface User {
    /**
     * The unique id of the User. This will be prefixed with `usr_`
     * @type {string}
     * @memberof User
     */
    'id'?: string;
    /**
     * The email of the User
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'first_name'?: string;
    /**
     * The Customer\'s billing address.
     * @type {Address}
     * @memberof User
     */
    'last_name'?: Address;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'deleted_at'?: string;
    /**
     * 
     * @type {object}
     * @memberof User
     */
    'metadata'?: object;
}

/**
 * AppsApi - axios parameter creator
 * @export
 */
export const AppsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a list of applications.
         * @summary List applications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApps: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/apps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a token for an application.
         * @summary Generates a token for an application.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApps: async (uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/apps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppsApi - functional programming interface
 * @export
 */
export const AppsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a list of applications.
         * @summary List applications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApps(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApps(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generates a token for an application.
         * @summary Generates a token for an application.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApps(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApps(uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AppsApi - factory interface
 * @export
 */
export const AppsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppsApiFp(configuration)
    return {
        /**
         * Retrieve a list of applications.
         * @summary List applications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApps(options?: any): AxiosPromise<object> {
            return localVarFp.getApps(options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a token for an application.
         * @summary Generates a token for an application.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApps(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postApps(uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AppsApi - object-oriented interface
 * @export
 * @class AppsApi
 * @extends {BaseAPI}
 */
export class AppsApi extends BaseAPI {
    /**
     * Retrieve a list of applications.
     * @summary List applications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public getApps(options?: AxiosRequestConfig) {
        return AppsApiFp(this.configuration).getApps(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates a token for an application.
     * @summary Generates a token for an application.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public postApps(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return AppsApiFp(this.configuration).postApps(uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets the currently logged in User.
         * @summary Get Session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuth: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logs a User in and authorizes them to manage Store settings.
         * @summary Authenticate a User
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuth: async (inlineObject?: InlineObject, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets the currently logged in User.
         * @summary Get Session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuth(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuth(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Logs a User in and authorizes them to manage Store settings.
         * @summary Authenticate a User
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAuth(inlineObject?: InlineObject, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAuth(inlineObject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Gets the currently logged in User.
         * @summary Get Session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuth(options?: any): AxiosPromise<object> {
            return localVarFp.getAuth(options).then((request) => request(axios, basePath));
        },
        /**
         * Logs a User in and authorizes them to manage Store settings.
         * @summary Authenticate a User
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuth(inlineObject?: InlineObject, options?: any): AxiosPromise<object> {
            return localVarFp.postAuth(inlineObject, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Gets the currently logged in User.
     * @summary Get Session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getAuth(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).getAuth(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Logs a User in and authorizes them to manage Store settings.
     * @summary Authenticate a User
     * @param {InlineObject} [inlineObject] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postAuth(inlineObject?: InlineObject, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).postAuth(inlineObject, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ClaimApi - axios parameter creator
 * @export
 */
export const ClaimApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancels a Claim
         * @summary Cancels a Claim
         * @param {string} id The id of the Order.
         * @param {string} claimId The id of the Claim.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersClaimCancel: async (id: string, claimId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postOrdersClaimCancel', 'id', id)
            // verify required parameter 'claimId' is not null or undefined
            assertParamExists('postOrdersClaimCancel', 'claimId', claimId)
            const localVarPath = `/orders/{id}/claims/{claim_id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"claim_id"}}`, encodeURIComponent(String(claimId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClaimApi - functional programming interface
 * @export
 */
export const ClaimApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClaimApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancels a Claim
         * @summary Cancels a Claim
         * @param {string} id The id of the Order.
         * @param {string} claimId The id of the Claim.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrdersClaimCancel(id: string, claimId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postOrdersClaimCancel(id, claimId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ClaimApi - factory interface
 * @export
 */
export const ClaimApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClaimApiFp(configuration)
    return {
        /**
         * Cancels a Claim
         * @summary Cancels a Claim
         * @param {string} id The id of the Order.
         * @param {string} claimId The id of the Claim.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersClaimCancel(id: string, claimId: string, options?: any): AxiosPromise<object> {
            return localVarFp.postOrdersClaimCancel(id, claimId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClaimApi - object-oriented interface
 * @export
 * @class ClaimApi
 * @extends {BaseAPI}
 */
export class ClaimApi extends BaseAPI {
    /**
     * Cancels a Claim
     * @summary Cancels a Claim
     * @param {string} id The id of the Order.
     * @param {string} claimId The id of the Claim.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClaimApi
     */
    public postOrdersClaimCancel(id: string, claimId: string, options?: AxiosRequestConfig) {
        return ClaimApiFp(this.configuration).postOrdersClaimCancel(id, claimId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CollectionApi - axios parameter creator
 * @export
 */
export const CollectionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a Product Collection.
         * @summary Delete a Product Collection
         * @param {string} id The id of the Collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollectionsCollection: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCollectionsCollection', 'id', id)
            const localVarPath = `/collections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes products associated with a Product Collection
         * @summary Removes products associated with a Product Collection
         * @param {string} id The id of the Collection.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsFromCollection: async (id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProductsFromCollection', 'id', id)
            const localVarPath = `/collections/{id}/products/batch`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of Product Collection.
         * @summary List Product Collections
         * @param {string} [limit] The number of collections to return.
         * @param {string} [offset] The offset of collections to return.
         * @param {string} [title] The title of collections to return.
         * @param {string} [handle] The handle of collections to return.
         * @param {object} [deletedAt] Date comparison for when resulting collections was deleted, i.e. less than, greater than etc.
         * @param {object} [createdAt] Date comparison for when resulting collections was created, i.e. less than, greater than etc.
         * @param {object} [updatedAt] Date comparison for when resulting collections was updated, i.e. less than, greater than etc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollections: async (limit?: string, offset?: string, title?: string, handle?: string, deletedAt?: object, createdAt?: object, updatedAt?: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (handle !== undefined) {
                localVarQueryParameter['handle'] = handle;
            }

            if (deletedAt !== undefined) {
                localVarQueryParameter['deleted_at'] = deletedAt;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Product Collection.
         * @summary Retrieve a Product Collection
         * @param {string} id The id of the Product Collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionsCollection: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCollectionsCollection', 'id', id)
            const localVarPath = `/collections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Product Collection.
         * @summary Create a Product Collection
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollections: async (uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Product Collection.
         * @summary Update a Product Collection
         * @param {string} id The id of the Collection.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionsCollection: async (id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postCollectionsCollection', 'id', id)
            const localVarPath = `/collections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates products associated with a Product Collection
         * @summary Updates products associated with a Product Collection
         * @param {string} id The id of the Collection.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsToCollection: async (id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postProductsToCollection', 'id', id)
            const localVarPath = `/collections/{id}/products/batch`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionApi - functional programming interface
 * @export
 */
export const CollectionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CollectionApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a Product Collection.
         * @summary Delete a Product Collection
         * @param {string} id The id of the Collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCollectionsCollection(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCollectionsCollection(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes products associated with a Product Collection
         * @summary Removes products associated with a Product Collection
         * @param {string} id The id of the Collection.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProductsFromCollection(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProductsFromCollection(id, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a list of Product Collection.
         * @summary List Product Collections
         * @param {string} [limit] The number of collections to return.
         * @param {string} [offset] The offset of collections to return.
         * @param {string} [title] The title of collections to return.
         * @param {string} [handle] The handle of collections to return.
         * @param {object} [deletedAt] Date comparison for when resulting collections was deleted, i.e. less than, greater than etc.
         * @param {object} [createdAt] Date comparison for when resulting collections was created, i.e. less than, greater than etc.
         * @param {object} [updatedAt] Date comparison for when resulting collections was updated, i.e. less than, greater than etc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollections(limit?: string, offset?: string, title?: string, handle?: string, deletedAt?: object, createdAt?: object, updatedAt?: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollections(limit, offset, title, handle, deletedAt, createdAt, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a Product Collection.
         * @summary Retrieve a Product Collection
         * @param {string} id The id of the Product Collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionsCollection(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionsCollection(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Product Collection.
         * @summary Create a Product Collection
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollections(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCollections(uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a Product Collection.
         * @summary Update a Product Collection
         * @param {string} id The id of the Collection.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollectionsCollection(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCollectionsCollection(id, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates products associated with a Product Collection
         * @summary Updates products associated with a Product Collection
         * @param {string} id The id of the Collection.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProductsToCollection(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postProductsToCollection(id, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CollectionApi - factory interface
 * @export
 */
export const CollectionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CollectionApiFp(configuration)
    return {
        /**
         * Deletes a Product Collection.
         * @summary Delete a Product Collection
         * @param {string} id The id of the Collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollectionsCollection(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteCollectionsCollection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes products associated with a Product Collection
         * @summary Removes products associated with a Product Collection
         * @param {string} id The id of the Collection.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsFromCollection(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProductsFromCollection(id, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of Product Collection.
         * @summary List Product Collections
         * @param {string} [limit] The number of collections to return.
         * @param {string} [offset] The offset of collections to return.
         * @param {string} [title] The title of collections to return.
         * @param {string} [handle] The handle of collections to return.
         * @param {object} [deletedAt] Date comparison for when resulting collections was deleted, i.e. less than, greater than etc.
         * @param {object} [createdAt] Date comparison for when resulting collections was created, i.e. less than, greater than etc.
         * @param {object} [updatedAt] Date comparison for when resulting collections was updated, i.e. less than, greater than etc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollections(limit?: string, offset?: string, title?: string, handle?: string, deletedAt?: object, createdAt?: object, updatedAt?: object, options?: any): AxiosPromise<object> {
            return localVarFp.getCollections(limit, offset, title, handle, deletedAt, createdAt, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Product Collection.
         * @summary Retrieve a Product Collection
         * @param {string} id The id of the Product Collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionsCollection(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.getCollectionsCollection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Product Collection.
         * @summary Create a Product Collection
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollections(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postCollections(uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a Product Collection.
         * @summary Update a Product Collection
         * @param {string} id The id of the Collection.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionsCollection(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postCollectionsCollection(id, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates products associated with a Product Collection
         * @summary Updates products associated with a Product Collection
         * @param {string} id The id of the Collection.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsToCollection(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<void> {
            return localVarFp.postProductsToCollection(id, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CollectionApi - object-oriented interface
 * @export
 * @class CollectionApi
 * @extends {BaseAPI}
 */
export class CollectionApi extends BaseAPI {
    /**
     * Deletes a Product Collection.
     * @summary Delete a Product Collection
     * @param {string} id The id of the Collection.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public deleteCollectionsCollection(id: string, options?: AxiosRequestConfig) {
        return CollectionApiFp(this.configuration).deleteCollectionsCollection(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes products associated with a Product Collection
     * @summary Removes products associated with a Product Collection
     * @param {string} id The id of the Collection.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public deleteProductsFromCollection(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return CollectionApiFp(this.configuration).deleteProductsFromCollection(id, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of Product Collection.
     * @summary List Product Collections
     * @param {string} [limit] The number of collections to return.
     * @param {string} [offset] The offset of collections to return.
     * @param {string} [title] The title of collections to return.
     * @param {string} [handle] The handle of collections to return.
     * @param {object} [deletedAt] Date comparison for when resulting collections was deleted, i.e. less than, greater than etc.
     * @param {object} [createdAt] Date comparison for when resulting collections was created, i.e. less than, greater than etc.
     * @param {object} [updatedAt] Date comparison for when resulting collections was updated, i.e. less than, greater than etc.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public getCollections(limit?: string, offset?: string, title?: string, handle?: string, deletedAt?: object, createdAt?: object, updatedAt?: object, options?: AxiosRequestConfig) {
        return CollectionApiFp(this.configuration).getCollections(limit, offset, title, handle, deletedAt, createdAt, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Product Collection.
     * @summary Retrieve a Product Collection
     * @param {string} id The id of the Product Collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public getCollectionsCollection(id: string, options?: AxiosRequestConfig) {
        return CollectionApiFp(this.configuration).getCollectionsCollection(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Product Collection.
     * @summary Create a Product Collection
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public postCollections(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return CollectionApiFp(this.configuration).postCollections(uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a Product Collection.
     * @summary Update a Product Collection
     * @param {string} id The id of the Collection.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public postCollectionsCollection(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return CollectionApiFp(this.configuration).postCollectionsCollection(id, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates products associated with a Product Collection
     * @summary Updates products associated with a Product Collection
     * @param {string} id The id of the Collection.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public postProductsToCollection(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return CollectionApiFp(this.configuration).postProductsToCollection(id, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomerApi - axios parameter creator
 * @export
 */
export const CustomerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of Customers.
         * @summary List Customers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Customer.
         * @summary Retrieve a Customer
         * @param {string} id The id of the Customer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersCustomer: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCustomersCustomer', 'id', id)
            const localVarPath = `/customers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Customer.
         * @summary Create a Customer
         * @param {InlineObject1} [inlineObject1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomers: async (inlineObject1?: InlineObject1, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Customer.
         * @summary Update a Customer
         * @param {string} id The id of the Customer.
         * @param {Array<string>} [expand] 
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomersCustomer: async (id: string, expand?: Array<string>, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postCustomersCustomer', 'id', id)
            const localVarPath = `/customers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand.join(COLLECTION_FORMATS.csv);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerApi - functional programming interface
 * @export
 */
export const CustomerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomerApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a list of Customers.
         * @summary List Customers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a Customer.
         * @summary Retrieve a Customer
         * @param {string} id The id of the Customer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomersCustomer(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomersCustomer(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Customer.
         * @summary Create a Customer
         * @param {InlineObject1} [inlineObject1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCustomers(inlineObject1?: InlineObject1, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCustomers(inlineObject1, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a Customer.
         * @summary Update a Customer
         * @param {string} id The id of the Customer.
         * @param {Array<string>} [expand] 
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCustomersCustomer(id: string, expand?: Array<string>, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCustomersCustomer(id, expand, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomerApi - factory interface
 * @export
 */
export const CustomerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomerApiFp(configuration)
    return {
        /**
         * Retrieves a list of Customers.
         * @summary List Customers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomers(options?: any): AxiosPromise<object> {
            return localVarFp.getCustomers(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Customer.
         * @summary Retrieve a Customer
         * @param {string} id The id of the Customer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersCustomer(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.getCustomersCustomer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Customer.
         * @summary Create a Customer
         * @param {InlineObject1} [inlineObject1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomers(inlineObject1?: InlineObject1, options?: any): AxiosPromise<object> {
            return localVarFp.postCustomers(inlineObject1, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a Customer.
         * @summary Update a Customer
         * @param {string} id The id of the Customer.
         * @param {Array<string>} [expand] 
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomersCustomer(id: string, expand?: Array<string>, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postCustomersCustomer(id, expand, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomerApi - object-oriented interface
 * @export
 * @class CustomerApi
 * @extends {BaseAPI}
 */
export class CustomerApi extends BaseAPI {
    /**
     * Retrieves a list of Customers.
     * @summary List Customers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public getCustomers(options?: AxiosRequestConfig) {
        return CustomerApiFp(this.configuration).getCustomers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Customer.
     * @summary Retrieve a Customer
     * @param {string} id The id of the Customer.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public getCustomersCustomer(id: string, options?: AxiosRequestConfig) {
        return CustomerApiFp(this.configuration).getCustomersCustomer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Customer.
     * @summary Create a Customer
     * @param {InlineObject1} [inlineObject1] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public postCustomers(inlineObject1?: InlineObject1, options?: AxiosRequestConfig) {
        return CustomerApiFp(this.configuration).postCustomers(inlineObject1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a Customer.
     * @summary Update a Customer
     * @param {string} id The id of the Customer.
     * @param {Array<string>} [expand] 
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public postCustomersCustomer(id: string, expand?: Array<string>, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return CustomerApiFp(this.configuration).postCustomersCustomer(id, expand, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomerGroupApi - axios parameter creator
 * @export
 */
export const CustomerGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a CustomerGroup.
         * @summary Delete a CustomerGroup
         * @param {string} id The id of the Customer Group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomerGroupsCustomerGroup: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCustomerGroupsCustomerGroup', 'id', id)
            const localVarPath = `/customer-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Customer Group.
         * @summary Retrieve a CustomerGroup
         * @param {string} id The id of the Customer Group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerGroupsGroup: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCustomerGroupsGroup', 'id', id)
            const localVarPath = `/customer-group/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a CustomerGroup.
         * @summary Create a CustomerGroup
         * @param {InlineObject2} [inlineObject2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomerGroups: async (inlineObject2?: InlineObject2, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/customer-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a CustomerGroup.
         * @summary Update a CustomerGroup
         * @param {string} id The id of the customer group.
         * @param {InlineObject3} [inlineObject3] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomerGroupsGroup: async (id: string, inlineObject3?: InlineObject3, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postCustomerGroupsGroup', 'id', id)
            const localVarPath = `/customer-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject3, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerGroupApi - functional programming interface
 * @export
 */
export const CustomerGroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomerGroupApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a CustomerGroup.
         * @summary Delete a CustomerGroup
         * @param {string} id The id of the Customer Group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomerGroupsCustomerGroup(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomerGroupsCustomerGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a Customer Group.
         * @summary Retrieve a CustomerGroup
         * @param {string} id The id of the Customer Group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerGroupsGroup(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomerGroupsGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a CustomerGroup.
         * @summary Create a CustomerGroup
         * @param {InlineObject2} [inlineObject2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCustomerGroups(inlineObject2?: InlineObject2, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCustomerGroups(inlineObject2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a CustomerGroup.
         * @summary Update a CustomerGroup
         * @param {string} id The id of the customer group.
         * @param {InlineObject3} [inlineObject3] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCustomerGroupsGroup(id: string, inlineObject3?: InlineObject3, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCustomerGroupsGroup(id, inlineObject3, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomerGroupApi - factory interface
 * @export
 */
export const CustomerGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomerGroupApiFp(configuration)
    return {
        /**
         * Deletes a CustomerGroup.
         * @summary Delete a CustomerGroup
         * @param {string} id The id of the Customer Group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomerGroupsCustomerGroup(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteCustomerGroupsCustomerGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Customer Group.
         * @summary Retrieve a CustomerGroup
         * @param {string} id The id of the Customer Group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerGroupsGroup(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.getCustomerGroupsGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a CustomerGroup.
         * @summary Create a CustomerGroup
         * @param {InlineObject2} [inlineObject2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomerGroups(inlineObject2?: InlineObject2, options?: any): AxiosPromise<object> {
            return localVarFp.postCustomerGroups(inlineObject2, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a CustomerGroup.
         * @summary Update a CustomerGroup
         * @param {string} id The id of the customer group.
         * @param {InlineObject3} [inlineObject3] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomerGroupsGroup(id: string, inlineObject3?: InlineObject3, options?: any): AxiosPromise<object> {
            return localVarFp.postCustomerGroupsGroup(id, inlineObject3, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomerGroupApi - object-oriented interface
 * @export
 * @class CustomerGroupApi
 * @extends {BaseAPI}
 */
export class CustomerGroupApi extends BaseAPI {
    /**
     * Deletes a CustomerGroup.
     * @summary Delete a CustomerGroup
     * @param {string} id The id of the Customer Group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerGroupApi
     */
    public deleteCustomerGroupsCustomerGroup(id: string, options?: AxiosRequestConfig) {
        return CustomerGroupApiFp(this.configuration).deleteCustomerGroupsCustomerGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Customer Group.
     * @summary Retrieve a CustomerGroup
     * @param {string} id The id of the Customer Group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerGroupApi
     */
    public getCustomerGroupsGroup(id: string, options?: AxiosRequestConfig) {
        return CustomerGroupApiFp(this.configuration).getCustomerGroupsGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a CustomerGroup.
     * @summary Create a CustomerGroup
     * @param {InlineObject2} [inlineObject2] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerGroupApi
     */
    public postCustomerGroups(inlineObject2?: InlineObject2, options?: AxiosRequestConfig) {
        return CustomerGroupApiFp(this.configuration).postCustomerGroups(inlineObject2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a CustomerGroup.
     * @summary Update a CustomerGroup
     * @param {string} id The id of the customer group.
     * @param {InlineObject3} [inlineObject3] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerGroupApi
     */
    public postCustomerGroupsGroup(id: string, inlineObject3?: InlineObject3, options?: AxiosRequestConfig) {
        return CustomerGroupApiFp(this.configuration).postCustomerGroupsGroup(id, inlineObject3, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DiscountApi - axios parameter creator
 * @export
 */
export const DiscountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a Discount.
         * @summary Delete a Discount
         * @param {string} id The id of the Discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiscountsDiscount: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDiscountsDiscount', 'id', id)
            const localVarPath = `/discounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a dynamic code from a Discount.
         * @summary Delete a dynamic code
         * @param {string} id The id of the Discount
         * @param {string} code The id of the Discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiscountsDiscountDynamicCodesCode: async (id: string, code: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDiscountsDiscountDynamicCodesCode', 'id', id)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('deleteDiscountsDiscountDynamicCodesCode', 'code', code)
            const localVarPath = `/discounts/{id}/dynamic-codes/{code}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a Product from the list of Products that a Discount can be used for.
         * @summary Remove Product availability
         * @param {string} id The id of the Discount.
         * @param {string} productId The id of the Product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiscountsDiscountProductsProduct: async (id: string, productId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDiscountsDiscountProductsProduct', 'id', id)
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('deleteDiscountsDiscountProductsProduct', 'productId', productId)
            const localVarPath = `/discounts/{id}/products/{product_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a Region from the list of Regions that a Discount can be used in.
         * @summary Remove Region availability
         * @param {string} id The id of the Discount.
         * @param {string} regionId The id of the Region.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiscountsDiscountRegionsRegion: async (id: string, regionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDiscountsDiscountRegionsRegion', 'id', id)
            // verify required parameter 'regionId' is not null or undefined
            assertParamExists('deleteDiscountsDiscountRegionsRegion', 'regionId', regionId)
            const localVarPath = `/discounts/{id}/regions/{region_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"region_id"}}`, encodeURIComponent(String(regionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of Discounts
         * @summary List Discounts
         * @param {string} [q] Search query applied on results.
         * @param {boolean} [isDynamic] Return only dynamic discounts.
         * @param {boolean} [isDisabled] Return only disabled discounts.
         * @param {number} [limit] The number of items in the response
         * @param {number} [offset] The offset of items in response
         * @param {string} [expand] Comma separated list of relations to include in the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiscounts: async (q?: string, isDynamic?: boolean, isDisabled?: boolean, limit?: number, offset?: number, expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/discounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (isDynamic !== undefined) {
                localVarQueryParameter['is_dynamic'] = isDynamic;
            }

            if (isDisabled !== undefined) {
                localVarQueryParameter['is_disabled'] = isDisabled;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Discount
         * @summary Retrieve a Discount
         * @param {string} id The id of the Discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiscountsDiscount: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDiscountsDiscount', 'id', id)
            const localVarPath = `/discounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Discount by its discount code
         * @summary Retrieve a Discount by code
         * @param {string} code The code of the Discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiscountsDiscountCode: async (code: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('getDiscountsDiscountCode', 'code', code)
            const localVarPath = `/discounts/code/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Discount with a given set of rules that define how the Discount behaves.
         * @summary Creates a Discount
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDiscounts: async (uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/discounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Discount with a given set of rules that define how the Discount behaves.
         * @summary Update a Discount
         * @param {string} id The id of the Discount.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDiscountsDiscount: async (id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postDiscountsDiscount', 'id', id)
            const localVarPath = `/discounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a unique code that can map to a parent Discount. This is useful if you want to automatically generate codes with the same behaviour.
         * @summary Create a dynamic Discount code
         * @param {string} id The id of the Discount to create the dynamic code from.\&quot;
         * @param {InlineObject4} [inlineObject4] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDiscountsDiscountDynamicCodes: async (id: string, inlineObject4?: InlineObject4, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postDiscountsDiscountDynamicCodes', 'id', id)
            const localVarPath = `/discounts/{id}/dynamic-codes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject4, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a Product to the list of Products that a Discount can be used for.
         * @summary Adds Product availability
         * @param {string} id The id of the Discount.
         * @param {string} productId The id of the Product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDiscountsDiscountProductsProduct: async (id: string, productId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postDiscountsDiscountProductsProduct', 'id', id)
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('postDiscountsDiscountProductsProduct', 'productId', productId)
            const localVarPath = `/discounts/{id}/products/{product_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a Region to the list of Regions that a Discount can be used in.
         * @summary Adds Region availability
         * @param {string} id The id of the Discount.
         * @param {string} regionId The id of the Region.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDiscountsDiscountRegionsRegion: async (id: string, regionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postDiscountsDiscountRegionsRegion', 'id', id)
            // verify required parameter 'regionId' is not null or undefined
            assertParamExists('postDiscountsDiscountRegionsRegion', 'regionId', regionId)
            const localVarPath = `/discounts/{id}/regions/{region_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"region_id"}}`, encodeURIComponent(String(regionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DiscountApi - functional programming interface
 * @export
 */
export const DiscountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DiscountApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a Discount.
         * @summary Delete a Discount
         * @param {string} id The id of the Discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDiscountsDiscount(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDiscountsDiscount(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a dynamic code from a Discount.
         * @summary Delete a dynamic code
         * @param {string} id The id of the Discount
         * @param {string} code The id of the Discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDiscountsDiscountDynamicCodesCode(id: string, code: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDiscountsDiscountDynamicCodesCode(id, code, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes a Product from the list of Products that a Discount can be used for.
         * @summary Remove Product availability
         * @param {string} id The id of the Discount.
         * @param {string} productId The id of the Product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDiscountsDiscountProductsProduct(id: string, productId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDiscountsDiscountProductsProduct(id, productId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes a Region from the list of Regions that a Discount can be used in.
         * @summary Remove Region availability
         * @param {string} id The id of the Discount.
         * @param {string} regionId The id of the Region.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDiscountsDiscountRegionsRegion(id: string, regionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDiscountsDiscountRegionsRegion(id, regionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of Discounts
         * @summary List Discounts
         * @param {string} [q] Search query applied on results.
         * @param {boolean} [isDynamic] Return only dynamic discounts.
         * @param {boolean} [isDisabled] Return only disabled discounts.
         * @param {number} [limit] The number of items in the response
         * @param {number} [offset] The offset of items in response
         * @param {string} [expand] Comma separated list of relations to include in the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDiscounts(q?: string, isDynamic?: boolean, isDisabled?: boolean, limit?: number, offset?: number, expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDiscounts(q, isDynamic, isDisabled, limit, offset, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a Discount
         * @summary Retrieve a Discount
         * @param {string} id The id of the Discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDiscountsDiscount(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDiscountsDiscount(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a Discount by its discount code
         * @summary Retrieve a Discount by code
         * @param {string} code The code of the Discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDiscountsDiscountCode(code: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDiscountsDiscountCode(code, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Discount with a given set of rules that define how the Discount behaves.
         * @summary Creates a Discount
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postDiscounts(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postDiscounts(uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a Discount with a given set of rules that define how the Discount behaves.
         * @summary Update a Discount
         * @param {string} id The id of the Discount.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postDiscountsDiscount(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postDiscountsDiscount(id, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a unique code that can map to a parent Discount. This is useful if you want to automatically generate codes with the same behaviour.
         * @summary Create a dynamic Discount code
         * @param {string} id The id of the Discount to create the dynamic code from.\&quot;
         * @param {InlineObject4} [inlineObject4] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postDiscountsDiscountDynamicCodes(id: string, inlineObject4?: InlineObject4, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postDiscountsDiscountDynamicCodes(id, inlineObject4, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a Product to the list of Products that a Discount can be used for.
         * @summary Adds Product availability
         * @param {string} id The id of the Discount.
         * @param {string} productId The id of the Product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postDiscountsDiscountProductsProduct(id: string, productId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postDiscountsDiscountProductsProduct(id, productId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a Region to the list of Regions that a Discount can be used in.
         * @summary Adds Region availability
         * @param {string} id The id of the Discount.
         * @param {string} regionId The id of the Region.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postDiscountsDiscountRegionsRegion(id: string, regionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postDiscountsDiscountRegionsRegion(id, regionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DiscountApi - factory interface
 * @export
 */
export const DiscountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DiscountApiFp(configuration)
    return {
        /**
         * Deletes a Discount.
         * @summary Delete a Discount
         * @param {string} id The id of the Discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiscountsDiscount(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteDiscountsDiscount(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a dynamic code from a Discount.
         * @summary Delete a dynamic code
         * @param {string} id The id of the Discount
         * @param {string} code The id of the Discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiscountsDiscountDynamicCodesCode(id: string, code: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteDiscountsDiscountDynamicCodesCode(id, code, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a Product from the list of Products that a Discount can be used for.
         * @summary Remove Product availability
         * @param {string} id The id of the Discount.
         * @param {string} productId The id of the Product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiscountsDiscountProductsProduct(id: string, productId: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteDiscountsDiscountProductsProduct(id, productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a Region from the list of Regions that a Discount can be used in.
         * @summary Remove Region availability
         * @param {string} id The id of the Discount.
         * @param {string} regionId The id of the Region.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiscountsDiscountRegionsRegion(id: string, regionId: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteDiscountsDiscountRegionsRegion(id, regionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of Discounts
         * @summary List Discounts
         * @param {string} [q] Search query applied on results.
         * @param {boolean} [isDynamic] Return only dynamic discounts.
         * @param {boolean} [isDisabled] Return only disabled discounts.
         * @param {number} [limit] The number of items in the response
         * @param {number} [offset] The offset of items in response
         * @param {string} [expand] Comma separated list of relations to include in the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiscounts(q?: string, isDynamic?: boolean, isDisabled?: boolean, limit?: number, offset?: number, expand?: string, options?: any): AxiosPromise<object> {
            return localVarFp.getDiscounts(q, isDynamic, isDisabled, limit, offset, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Discount
         * @summary Retrieve a Discount
         * @param {string} id The id of the Discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiscountsDiscount(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.getDiscountsDiscount(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Discount by its discount code
         * @summary Retrieve a Discount by code
         * @param {string} code The code of the Discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiscountsDiscountCode(code: string, options?: any): AxiosPromise<object> {
            return localVarFp.getDiscountsDiscountCode(code, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Discount with a given set of rules that define how the Discount behaves.
         * @summary Creates a Discount
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDiscounts(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postDiscounts(uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a Discount with a given set of rules that define how the Discount behaves.
         * @summary Update a Discount
         * @param {string} id The id of the Discount.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDiscountsDiscount(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postDiscountsDiscount(id, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a unique code that can map to a parent Discount. This is useful if you want to automatically generate codes with the same behaviour.
         * @summary Create a dynamic Discount code
         * @param {string} id The id of the Discount to create the dynamic code from.\&quot;
         * @param {InlineObject4} [inlineObject4] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDiscountsDiscountDynamicCodes(id: string, inlineObject4?: InlineObject4, options?: any): AxiosPromise<object> {
            return localVarFp.postDiscountsDiscountDynamicCodes(id, inlineObject4, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a Product to the list of Products that a Discount can be used for.
         * @summary Adds Product availability
         * @param {string} id The id of the Discount.
         * @param {string} productId The id of the Product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDiscountsDiscountProductsProduct(id: string, productId: string, options?: any): AxiosPromise<object> {
            return localVarFp.postDiscountsDiscountProductsProduct(id, productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a Region to the list of Regions that a Discount can be used in.
         * @summary Adds Region availability
         * @param {string} id The id of the Discount.
         * @param {string} regionId The id of the Region.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDiscountsDiscountRegionsRegion(id: string, regionId: string, options?: any): AxiosPromise<object> {
            return localVarFp.postDiscountsDiscountRegionsRegion(id, regionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DiscountApi - object-oriented interface
 * @export
 * @class DiscountApi
 * @extends {BaseAPI}
 */
export class DiscountApi extends BaseAPI {
    /**
     * Deletes a Discount.
     * @summary Delete a Discount
     * @param {string} id The id of the Discount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    public deleteDiscountsDiscount(id: string, options?: AxiosRequestConfig) {
        return DiscountApiFp(this.configuration).deleteDiscountsDiscount(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a dynamic code from a Discount.
     * @summary Delete a dynamic code
     * @param {string} id The id of the Discount
     * @param {string} code The id of the Discount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    public deleteDiscountsDiscountDynamicCodesCode(id: string, code: string, options?: AxiosRequestConfig) {
        return DiscountApiFp(this.configuration).deleteDiscountsDiscountDynamicCodesCode(id, code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a Product from the list of Products that a Discount can be used for.
     * @summary Remove Product availability
     * @param {string} id The id of the Discount.
     * @param {string} productId The id of the Product.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    public deleteDiscountsDiscountProductsProduct(id: string, productId: string, options?: AxiosRequestConfig) {
        return DiscountApiFp(this.configuration).deleteDiscountsDiscountProductsProduct(id, productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a Region from the list of Regions that a Discount can be used in.
     * @summary Remove Region availability
     * @param {string} id The id of the Discount.
     * @param {string} regionId The id of the Region.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    public deleteDiscountsDiscountRegionsRegion(id: string, regionId: string, options?: AxiosRequestConfig) {
        return DiscountApiFp(this.configuration).deleteDiscountsDiscountRegionsRegion(id, regionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of Discounts
     * @summary List Discounts
     * @param {string} [q] Search query applied on results.
     * @param {boolean} [isDynamic] Return only dynamic discounts.
     * @param {boolean} [isDisabled] Return only disabled discounts.
     * @param {number} [limit] The number of items in the response
     * @param {number} [offset] The offset of items in response
     * @param {string} [expand] Comma separated list of relations to include in the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    public getDiscounts(q?: string, isDynamic?: boolean, isDisabled?: boolean, limit?: number, offset?: number, expand?: string, options?: AxiosRequestConfig) {
        return DiscountApiFp(this.configuration).getDiscounts(q, isDynamic, isDisabled, limit, offset, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Discount
     * @summary Retrieve a Discount
     * @param {string} id The id of the Discount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    public getDiscountsDiscount(id: string, options?: AxiosRequestConfig) {
        return DiscountApiFp(this.configuration).getDiscountsDiscount(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Discount by its discount code
     * @summary Retrieve a Discount by code
     * @param {string} code The code of the Discount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    public getDiscountsDiscountCode(code: string, options?: AxiosRequestConfig) {
        return DiscountApiFp(this.configuration).getDiscountsDiscountCode(code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Discount with a given set of rules that define how the Discount behaves.
     * @summary Creates a Discount
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    public postDiscounts(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return DiscountApiFp(this.configuration).postDiscounts(uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a Discount with a given set of rules that define how the Discount behaves.
     * @summary Update a Discount
     * @param {string} id The id of the Discount.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    public postDiscountsDiscount(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return DiscountApiFp(this.configuration).postDiscountsDiscount(id, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a unique code that can map to a parent Discount. This is useful if you want to automatically generate codes with the same behaviour.
     * @summary Create a dynamic Discount code
     * @param {string} id The id of the Discount to create the dynamic code from.\&quot;
     * @param {InlineObject4} [inlineObject4] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    public postDiscountsDiscountDynamicCodes(id: string, inlineObject4?: InlineObject4, options?: AxiosRequestConfig) {
        return DiscountApiFp(this.configuration).postDiscountsDiscountDynamicCodes(id, inlineObject4, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a Product to the list of Products that a Discount can be used for.
     * @summary Adds Product availability
     * @param {string} id The id of the Discount.
     * @param {string} productId The id of the Product.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    public postDiscountsDiscountProductsProduct(id: string, productId: string, options?: AxiosRequestConfig) {
        return DiscountApiFp(this.configuration).postDiscountsDiscountProductsProduct(id, productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a Region to the list of Regions that a Discount can be used in.
     * @summary Adds Region availability
     * @param {string} id The id of the Discount.
     * @param {string} regionId The id of the Region.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    public postDiscountsDiscountRegionsRegion(id: string, regionId: string, options?: AxiosRequestConfig) {
        return DiscountApiFp(this.configuration).postDiscountsDiscountRegionsRegion(id, regionId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DraftOrderApi - axios parameter creator
 * @export
 */
export const DraftOrderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a Draft Order
         * @summary Delete a Draft Order
         * @param {string} id The id of the Draft Order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDraftOrdersDraftOrder: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDraftOrdersDraftOrder', 'id', id)
            const localVarPath = `/draft-orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a Line Item from a Draft Order.
         * @summary Delete a Line Item
         * @param {string} id The id of the Draft Order.
         * @param {string} lineId The id of the Draft Order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDraftOrdersDraftOrderLineItemsItem: async (id: string, lineId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDraftOrdersDraftOrderLineItemsItem', 'id', id)
            // verify required parameter 'lineId' is not null or undefined
            assertParamExists('deleteDraftOrdersDraftOrderLineItemsItem', 'lineId', lineId)
            const localVarPath = `/draft-orders/{id}/line-items/{line_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"line_id"}}`, encodeURIComponent(String(lineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves an list of Draft Orders
         * @summary List Draft Orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDraftOrders: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/draft-orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Draft Order.
         * @summary Retrieve a Draft Order
         * @param {string} id The id of the Draft Order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDraftOrdersDraftOrder: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDraftOrdersDraftOrder', 'id', id)
            const localVarPath = `/draft-orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Draft Order
         * @summary Create a Draft Order
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDraftOrders: async (uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/draft-orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Draft Order.
         * @summary Update a Draft Order\"
         * @param {string} id The id of the Draft Order.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDraftOrdersDraftOrder: async (id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postDraftOrdersDraftOrder', 'id', id)
            const localVarPath = `/admin/draft-orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Line Item for the Draft Order
         * @summary Create a Line Item for Draft Order
         * @param {string} id The id of the Draft Order.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDraftOrdersDraftOrderLineItems: async (id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postDraftOrdersDraftOrderLineItems', 'id', id)
            const localVarPath = `/draft-orders/{id}/line-items`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Line Item for a Draft Order
         * @summary Update a Line Item for a Draft Order
         * @param {string} id The id of the Draft Order.
         * @param {string} lineId The id of the Line Item.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDraftOrdersDraftOrderLineItemsItem: async (id: string, lineId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postDraftOrdersDraftOrderLineItemsItem', 'id', id)
            // verify required parameter 'lineId' is not null or undefined
            assertParamExists('postDraftOrdersDraftOrderLineItemsItem', 'lineId', lineId)
            const localVarPath = `/draft-orders/{id}/line-items/{line_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"line_id"}}`, encodeURIComponent(String(lineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers a payment for a Draft Order.
         * @summary Registers a payment for a Draft Order
         * @param {string} id The Draft Order id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDraftOrdersDraftOrderRegisterPayment: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postDraftOrdersDraftOrderRegisterPayment', 'id', id)
            const localVarPath = `/draft-orders/{id}/register-payment`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DraftOrderApi - functional programming interface
 * @export
 */
export const DraftOrderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DraftOrderApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a Draft Order
         * @summary Delete a Draft Order
         * @param {string} id The id of the Draft Order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDraftOrdersDraftOrder(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDraftOrdersDraftOrder(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes a Line Item from a Draft Order.
         * @summary Delete a Line Item
         * @param {string} id The id of the Draft Order.
         * @param {string} lineId The id of the Draft Order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDraftOrdersDraftOrderLineItemsItem(id: string, lineId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDraftOrdersDraftOrderLineItemsItem(id, lineId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves an list of Draft Orders
         * @summary List Draft Orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDraftOrders(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDraftOrders(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a Draft Order.
         * @summary Retrieve a Draft Order
         * @param {string} id The id of the Draft Order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDraftOrdersDraftOrder(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDraftOrdersDraftOrder(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Draft Order
         * @summary Create a Draft Order
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postDraftOrders(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postDraftOrders(uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a Draft Order.
         * @summary Update a Draft Order\"
         * @param {string} id The id of the Draft Order.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postDraftOrdersDraftOrder(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postDraftOrdersDraftOrder(id, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Line Item for the Draft Order
         * @summary Create a Line Item for Draft Order
         * @param {string} id The id of the Draft Order.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postDraftOrdersDraftOrderLineItems(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postDraftOrdersDraftOrderLineItems(id, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a Line Item for a Draft Order
         * @summary Update a Line Item for a Draft Order
         * @param {string} id The id of the Draft Order.
         * @param {string} lineId The id of the Line Item.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postDraftOrdersDraftOrderLineItemsItem(id: string, lineId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postDraftOrdersDraftOrderLineItemsItem(id, lineId, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Registers a payment for a Draft Order.
         * @summary Registers a payment for a Draft Order
         * @param {string} id The Draft Order id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postDraftOrdersDraftOrderRegisterPayment(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postDraftOrdersDraftOrderRegisterPayment(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DraftOrderApi - factory interface
 * @export
 */
export const DraftOrderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DraftOrderApiFp(configuration)
    return {
        /**
         * Deletes a Draft Order
         * @summary Delete a Draft Order
         * @param {string} id The id of the Draft Order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDraftOrdersDraftOrder(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteDraftOrdersDraftOrder(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a Line Item from a Draft Order.
         * @summary Delete a Line Item
         * @param {string} id The id of the Draft Order.
         * @param {string} lineId The id of the Draft Order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDraftOrdersDraftOrderLineItemsItem(id: string, lineId: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteDraftOrdersDraftOrderLineItemsItem(id, lineId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves an list of Draft Orders
         * @summary List Draft Orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDraftOrders(options?: any): AxiosPromise<object> {
            return localVarFp.getDraftOrders(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Draft Order.
         * @summary Retrieve a Draft Order
         * @param {string} id The id of the Draft Order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDraftOrdersDraftOrder(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.getDraftOrdersDraftOrder(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Draft Order
         * @summary Create a Draft Order
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDraftOrders(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postDraftOrders(uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a Draft Order.
         * @summary Update a Draft Order\"
         * @param {string} id The id of the Draft Order.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDraftOrdersDraftOrder(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postDraftOrdersDraftOrder(id, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Line Item for the Draft Order
         * @summary Create a Line Item for Draft Order
         * @param {string} id The id of the Draft Order.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDraftOrdersDraftOrderLineItems(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postDraftOrdersDraftOrderLineItems(id, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a Line Item for a Draft Order
         * @summary Update a Line Item for a Draft Order
         * @param {string} id The id of the Draft Order.
         * @param {string} lineId The id of the Line Item.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDraftOrdersDraftOrderLineItemsItem(id: string, lineId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postDraftOrdersDraftOrderLineItemsItem(id, lineId, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Registers a payment for a Draft Order.
         * @summary Registers a payment for a Draft Order
         * @param {string} id The Draft Order id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDraftOrdersDraftOrderRegisterPayment(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.postDraftOrdersDraftOrderRegisterPayment(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DraftOrderApi - object-oriented interface
 * @export
 * @class DraftOrderApi
 * @extends {BaseAPI}
 */
export class DraftOrderApi extends BaseAPI {
    /**
     * Deletes a Draft Order
     * @summary Delete a Draft Order
     * @param {string} id The id of the Draft Order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DraftOrderApi
     */
    public deleteDraftOrdersDraftOrder(id: string, options?: AxiosRequestConfig) {
        return DraftOrderApiFp(this.configuration).deleteDraftOrdersDraftOrder(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a Line Item from a Draft Order.
     * @summary Delete a Line Item
     * @param {string} id The id of the Draft Order.
     * @param {string} lineId The id of the Draft Order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DraftOrderApi
     */
    public deleteDraftOrdersDraftOrderLineItemsItem(id: string, lineId: string, options?: AxiosRequestConfig) {
        return DraftOrderApiFp(this.configuration).deleteDraftOrdersDraftOrderLineItemsItem(id, lineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves an list of Draft Orders
     * @summary List Draft Orders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DraftOrderApi
     */
    public getDraftOrders(options?: AxiosRequestConfig) {
        return DraftOrderApiFp(this.configuration).getDraftOrders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Draft Order.
     * @summary Retrieve a Draft Order
     * @param {string} id The id of the Draft Order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DraftOrderApi
     */
    public getDraftOrdersDraftOrder(id: string, options?: AxiosRequestConfig) {
        return DraftOrderApiFp(this.configuration).getDraftOrdersDraftOrder(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Draft Order
     * @summary Create a Draft Order
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DraftOrderApi
     */
    public postDraftOrders(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return DraftOrderApiFp(this.configuration).postDraftOrders(uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a Draft Order.
     * @summary Update a Draft Order\"
     * @param {string} id The id of the Draft Order.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DraftOrderApi
     */
    public postDraftOrdersDraftOrder(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return DraftOrderApiFp(this.configuration).postDraftOrdersDraftOrder(id, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Line Item for the Draft Order
     * @summary Create a Line Item for Draft Order
     * @param {string} id The id of the Draft Order.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DraftOrderApi
     */
    public postDraftOrdersDraftOrderLineItems(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return DraftOrderApiFp(this.configuration).postDraftOrdersDraftOrderLineItems(id, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a Line Item for a Draft Order
     * @summary Update a Line Item for a Draft Order
     * @param {string} id The id of the Draft Order.
     * @param {string} lineId The id of the Line Item.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DraftOrderApi
     */
    public postDraftOrdersDraftOrderLineItemsItem(id: string, lineId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return DraftOrderApiFp(this.configuration).postDraftOrdersDraftOrderLineItemsItem(id, lineId, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registers a payment for a Draft Order.
     * @summary Registers a payment for a Draft Order
     * @param {string} id The Draft Order id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DraftOrderApi
     */
    public postDraftOrdersDraftOrderRegisterPayment(id: string, options?: AxiosRequestConfig) {
        return DraftOrderApiFp(this.configuration).postDraftOrdersDraftOrderRegisterPayment(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FulfillmentApi - axios parameter creator
 * @export
 */
export const FulfillmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Registers a Fulfillment as canceled.
         * @summary Cancels a fulfilmment related to a Claim
         * @param {string} id The id of the Order which the Claim relates to.
         * @param {string} claimId The id of the Claim which the Fulfillment relates to.
         * @param {string} fulfillmentId The id of the Fulfillment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersClaimFulfillmentsCancel: async (id: string, claimId: string, fulfillmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postOrdersClaimFulfillmentsCancel', 'id', id)
            // verify required parameter 'claimId' is not null or undefined
            assertParamExists('postOrdersClaimFulfillmentsCancel', 'claimId', claimId)
            // verify required parameter 'fulfillmentId' is not null or undefined
            assertParamExists('postOrdersClaimFulfillmentsCancel', 'fulfillmentId', fulfillmentId)
            const localVarPath = `/orders/{id}/claims/{claim_id}/fulfillments/{fulfillment_id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"claim_id"}}`, encodeURIComponent(String(claimId)))
                .replace(`{${"fulfillment_id"}}`, encodeURIComponent(String(fulfillmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers a Fulfillment as canceled.
         * @summary Cancels a fulfilmment
         * @param {string} id The id of the Order which the Fulfillment relates to.
         * @param {string} fulfillmentId The id of the Fulfillment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderFulfillmentsCancel: async (id: string, fulfillmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postOrdersOrderFulfillmentsCancel', 'id', id)
            // verify required parameter 'fulfillmentId' is not null or undefined
            assertParamExists('postOrdersOrderFulfillmentsCancel', 'fulfillmentId', fulfillmentId)
            const localVarPath = `/orders/{id}/fulfillments/{fulfillment_id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"fulfillment_id"}}`, encodeURIComponent(String(fulfillmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers a Fulfillment as canceled.
         * @summary Cancels a fulfilmment related to a Swap
         * @param {string} id The id of the Order which the Swap relates to.
         * @param {string} swapId The id of the Swap which the Fulfillment relates to.
         * @param {string} fulfillmentId The id of the Fulfillment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersSwapFulfillmentsCancel: async (id: string, swapId: string, fulfillmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postOrdersSwapFulfillmentsCancel', 'id', id)
            // verify required parameter 'swapId' is not null or undefined
            assertParamExists('postOrdersSwapFulfillmentsCancel', 'swapId', swapId)
            // verify required parameter 'fulfillmentId' is not null or undefined
            assertParamExists('postOrdersSwapFulfillmentsCancel', 'fulfillmentId', fulfillmentId)
            const localVarPath = `/orders/{id}/swaps/{swap_id}/fulfillments/{fulfillment_id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"swap_id"}}`, encodeURIComponent(String(swapId)))
                .replace(`{${"fulfillment_id"}}`, encodeURIComponent(String(fulfillmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FulfillmentApi - functional programming interface
 * @export
 */
export const FulfillmentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FulfillmentApiAxiosParamCreator(configuration)
    return {
        /**
         * Registers a Fulfillment as canceled.
         * @summary Cancels a fulfilmment related to a Claim
         * @param {string} id The id of the Order which the Claim relates to.
         * @param {string} claimId The id of the Claim which the Fulfillment relates to.
         * @param {string} fulfillmentId The id of the Fulfillment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrdersClaimFulfillmentsCancel(id: string, claimId: string, fulfillmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postOrdersClaimFulfillmentsCancel(id, claimId, fulfillmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Registers a Fulfillment as canceled.
         * @summary Cancels a fulfilmment
         * @param {string} id The id of the Order which the Fulfillment relates to.
         * @param {string} fulfillmentId The id of the Fulfillment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrdersOrderFulfillmentsCancel(id: string, fulfillmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postOrdersOrderFulfillmentsCancel(id, fulfillmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Registers a Fulfillment as canceled.
         * @summary Cancels a fulfilmment related to a Swap
         * @param {string} id The id of the Order which the Swap relates to.
         * @param {string} swapId The id of the Swap which the Fulfillment relates to.
         * @param {string} fulfillmentId The id of the Fulfillment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrdersSwapFulfillmentsCancel(id: string, swapId: string, fulfillmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postOrdersSwapFulfillmentsCancel(id, swapId, fulfillmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FulfillmentApi - factory interface
 * @export
 */
export const FulfillmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FulfillmentApiFp(configuration)
    return {
        /**
         * Registers a Fulfillment as canceled.
         * @summary Cancels a fulfilmment related to a Claim
         * @param {string} id The id of the Order which the Claim relates to.
         * @param {string} claimId The id of the Claim which the Fulfillment relates to.
         * @param {string} fulfillmentId The id of the Fulfillment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersClaimFulfillmentsCancel(id: string, claimId: string, fulfillmentId: string, options?: any): AxiosPromise<object> {
            return localVarFp.postOrdersClaimFulfillmentsCancel(id, claimId, fulfillmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Registers a Fulfillment as canceled.
         * @summary Cancels a fulfilmment
         * @param {string} id The id of the Order which the Fulfillment relates to.
         * @param {string} fulfillmentId The id of the Fulfillment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderFulfillmentsCancel(id: string, fulfillmentId: string, options?: any): AxiosPromise<object> {
            return localVarFp.postOrdersOrderFulfillmentsCancel(id, fulfillmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Registers a Fulfillment as canceled.
         * @summary Cancels a fulfilmment related to a Swap
         * @param {string} id The id of the Order which the Swap relates to.
         * @param {string} swapId The id of the Swap which the Fulfillment relates to.
         * @param {string} fulfillmentId The id of the Fulfillment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersSwapFulfillmentsCancel(id: string, swapId: string, fulfillmentId: string, options?: any): AxiosPromise<object> {
            return localVarFp.postOrdersSwapFulfillmentsCancel(id, swapId, fulfillmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FulfillmentApi - object-oriented interface
 * @export
 * @class FulfillmentApi
 * @extends {BaseAPI}
 */
export class FulfillmentApi extends BaseAPI {
    /**
     * Registers a Fulfillment as canceled.
     * @summary Cancels a fulfilmment related to a Claim
     * @param {string} id The id of the Order which the Claim relates to.
     * @param {string} claimId The id of the Claim which the Fulfillment relates to.
     * @param {string} fulfillmentId The id of the Fulfillment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public postOrdersClaimFulfillmentsCancel(id: string, claimId: string, fulfillmentId: string, options?: AxiosRequestConfig) {
        return FulfillmentApiFp(this.configuration).postOrdersClaimFulfillmentsCancel(id, claimId, fulfillmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registers a Fulfillment as canceled.
     * @summary Cancels a fulfilmment
     * @param {string} id The id of the Order which the Fulfillment relates to.
     * @param {string} fulfillmentId The id of the Fulfillment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public postOrdersOrderFulfillmentsCancel(id: string, fulfillmentId: string, options?: AxiosRequestConfig) {
        return FulfillmentApiFp(this.configuration).postOrdersOrderFulfillmentsCancel(id, fulfillmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registers a Fulfillment as canceled.
     * @summary Cancels a fulfilmment related to a Swap
     * @param {string} id The id of the Order which the Swap relates to.
     * @param {string} swapId The id of the Swap which the Fulfillment relates to.
     * @param {string} fulfillmentId The id of the Fulfillment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public postOrdersSwapFulfillmentsCancel(id: string, swapId: string, fulfillmentId: string, options?: AxiosRequestConfig) {
        return FulfillmentApiFp(this.configuration).postOrdersSwapFulfillmentsCancel(id, swapId, fulfillmentId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GiftCardApi - axios parameter creator
 * @export
 */
export const GiftCardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a Gift Card
         * @summary Delete a Gift Card
         * @param {string} id The id of the Gift Card to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGiftCardsGiftCard: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteGiftCardsGiftCard', 'id', id)
            const localVarPath = `/gift-cards/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of Gift Cards.
         * @summary List Gift Cards
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGiftCards: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gift-cards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Gift Card.
         * @summary Retrieve a Gift Card
         * @param {string} id The id of the Gift Card.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGiftCardsGiftCard: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGiftCardsGiftCard', 'id', id)
            const localVarPath = `/gift-cards/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Gift Card that can redeemed by its unique code. The Gift Card is only valid within 1 region.
         * @summary Create a Gift Card
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGiftCards: async (uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gift-cards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Gift Card that can redeemed by its unique code. The Gift Card is only valid within 1 region.
         * @summary Create a Gift Card
         * @param {string} id The id of the Gift Card.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGiftCardsGiftCard: async (id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postGiftCardsGiftCard', 'id', id)
            const localVarPath = `/gift-cards/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GiftCardApi - functional programming interface
 * @export
 */
export const GiftCardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GiftCardApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a Gift Card
         * @summary Delete a Gift Card
         * @param {string} id The id of the Gift Card to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGiftCardsGiftCard(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGiftCardsGiftCard(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of Gift Cards.
         * @summary List Gift Cards
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGiftCards(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGiftCards(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a Gift Card.
         * @summary Retrieve a Gift Card
         * @param {string} id The id of the Gift Card.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGiftCardsGiftCard(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGiftCardsGiftCard(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Gift Card that can redeemed by its unique code. The Gift Card is only valid within 1 region.
         * @summary Create a Gift Card
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postGiftCards(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postGiftCards(uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Gift Card that can redeemed by its unique code. The Gift Card is only valid within 1 region.
         * @summary Create a Gift Card
         * @param {string} id The id of the Gift Card.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postGiftCardsGiftCard(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postGiftCardsGiftCard(id, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GiftCardApi - factory interface
 * @export
 */
export const GiftCardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GiftCardApiFp(configuration)
    return {
        /**
         * Deletes a Gift Card
         * @summary Delete a Gift Card
         * @param {string} id The id of the Gift Card to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGiftCardsGiftCard(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteGiftCardsGiftCard(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of Gift Cards.
         * @summary List Gift Cards
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGiftCards(options?: any): AxiosPromise<object> {
            return localVarFp.getGiftCards(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Gift Card.
         * @summary Retrieve a Gift Card
         * @param {string} id The id of the Gift Card.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGiftCardsGiftCard(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.getGiftCardsGiftCard(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Gift Card that can redeemed by its unique code. The Gift Card is only valid within 1 region.
         * @summary Create a Gift Card
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGiftCards(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postGiftCards(uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Gift Card that can redeemed by its unique code. The Gift Card is only valid within 1 region.
         * @summary Create a Gift Card
         * @param {string} id The id of the Gift Card.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGiftCardsGiftCard(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postGiftCardsGiftCard(id, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GiftCardApi - object-oriented interface
 * @export
 * @class GiftCardApi
 * @extends {BaseAPI}
 */
export class GiftCardApi extends BaseAPI {
    /**
     * Deletes a Gift Card
     * @summary Delete a Gift Card
     * @param {string} id The id of the Gift Card to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftCardApi
     */
    public deleteGiftCardsGiftCard(id: string, options?: AxiosRequestConfig) {
        return GiftCardApiFp(this.configuration).deleteGiftCardsGiftCard(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of Gift Cards.
     * @summary List Gift Cards
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftCardApi
     */
    public getGiftCards(options?: AxiosRequestConfig) {
        return GiftCardApiFp(this.configuration).getGiftCards(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Gift Card.
     * @summary Retrieve a Gift Card
     * @param {string} id The id of the Gift Card.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftCardApi
     */
    public getGiftCardsGiftCard(id: string, options?: AxiosRequestConfig) {
        return GiftCardApiFp(this.configuration).getGiftCardsGiftCard(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Gift Card that can redeemed by its unique code. The Gift Card is only valid within 1 region.
     * @summary Create a Gift Card
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftCardApi
     */
    public postGiftCards(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return GiftCardApiFp(this.configuration).postGiftCards(uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Gift Card that can redeemed by its unique code. The Gift Card is only valid within 1 region.
     * @summary Create a Gift Card
     * @param {string} id The id of the Gift Card.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftCardApi
     */
    public postGiftCardsGiftCard(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return GiftCardApiFp(this.configuration).postGiftCardsGiftCard(id, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InvitesApi - axios parameter creator
 * @export
 */
export const InvitesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates an Invite and triggers an \'invite\' created event
         * @summary Create an Invite
         * @param {string} inviteId The id of the Invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvitesInvite: async (inviteId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inviteId' is not null or undefined
            assertParamExists('deleteInvitesInvite', 'inviteId', inviteId)
            const localVarPath = `/invites/{invite_id}`
                .replace(`{${"invite_id"}}`, encodeURIComponent(String(inviteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all Invites
         * @summary Lists all Invites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvites: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an Invite and triggers an \'invite\' created event
         * @summary Create an Invite
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInvites: async (uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts an Invite and creates a corresponding user
         * @summary Accept an Invite
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInvitesInviteAccept: async (uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invites/accept`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resends an Invite by triggering the \'invite\' created event again
         * @summary Resend an Invite
         * @param {string} inviteId The id of the Invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInvitesInviteResend: async (inviteId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inviteId' is not null or undefined
            assertParamExists('postInvitesInviteResend', 'inviteId', inviteId)
            const localVarPath = `/invites/{invite_id}/resend`
                .replace(`{${"invite_id"}}`, encodeURIComponent(String(inviteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvitesApi - functional programming interface
 * @export
 */
export const InvitesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvitesApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates an Invite and triggers an \'invite\' created event
         * @summary Create an Invite
         * @param {string} inviteId The id of the Invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInvitesInvite(inviteId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInvitesInvite(inviteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all Invites
         * @summary Lists all Invites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvites(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvites(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates an Invite and triggers an \'invite\' created event
         * @summary Create an Invite
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postInvites(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postInvites(uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accepts an Invite and creates a corresponding user
         * @summary Accept an Invite
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postInvitesInviteAccept(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postInvitesInviteAccept(uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resends an Invite by triggering the \'invite\' created event again
         * @summary Resend an Invite
         * @param {string} inviteId The id of the Invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postInvitesInviteResend(inviteId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postInvitesInviteResend(inviteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InvitesApi - factory interface
 * @export
 */
export const InvitesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvitesApiFp(configuration)
    return {
        /**
         * Creates an Invite and triggers an \'invite\' created event
         * @summary Create an Invite
         * @param {string} inviteId The id of the Invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvitesInvite(inviteId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteInvitesInvite(inviteId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all Invites
         * @summary Lists all Invites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvites(options?: any): AxiosPromise<object> {
            return localVarFp.getInvites(options).then((request) => request(axios, basePath));
        },
        /**
         * Creates an Invite and triggers an \'invite\' created event
         * @summary Create an Invite
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInvites(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<void> {
            return localVarFp.postInvites(uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts an Invite and creates a corresponding user
         * @summary Accept an Invite
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInvitesInviteAccept(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<void> {
            return localVarFp.postInvitesInviteAccept(uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Resends an Invite by triggering the \'invite\' created event again
         * @summary Resend an Invite
         * @param {string} inviteId The id of the Invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInvitesInviteResend(inviteId: string, options?: any): AxiosPromise<void> {
            return localVarFp.postInvitesInviteResend(inviteId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvitesApi - object-oriented interface
 * @export
 * @class InvitesApi
 * @extends {BaseAPI}
 */
export class InvitesApi extends BaseAPI {
    /**
     * Creates an Invite and triggers an \'invite\' created event
     * @summary Create an Invite
     * @param {string} inviteId The id of the Invite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitesApi
     */
    public deleteInvitesInvite(inviteId: string, options?: AxiosRequestConfig) {
        return InvitesApiFp(this.configuration).deleteInvitesInvite(inviteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all Invites
     * @summary Lists all Invites
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitesApi
     */
    public getInvites(options?: AxiosRequestConfig) {
        return InvitesApiFp(this.configuration).getInvites(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates an Invite and triggers an \'invite\' created event
     * @summary Create an Invite
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitesApi
     */
    public postInvites(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return InvitesApiFp(this.configuration).postInvites(uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts an Invite and creates a corresponding user
     * @summary Accept an Invite
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitesApi
     */
    public postInvitesInviteAccept(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return InvitesApiFp(this.configuration).postInvitesInviteAccept(uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resends an Invite by triggering the \'invite\' created event again
     * @summary Resend an Invite
     * @param {string} inviteId The id of the Invite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitesApi
     */
    public postInvitesInviteResend(inviteId: string, options?: AxiosRequestConfig) {
        return InvitesApiFp(this.configuration).postInvitesInviteResend(inviteId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NoteApi - axios parameter creator
 * @export
 */
export const NoteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a Note.
         * @summary Deletes a Note
         * @param {string} id The id of the Note to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotesNote: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteNotesNote', 'id', id)
            const localVarPath = `/notes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of notes
         * @summary List Notes
         * @param {number} limit The number of notes to get
         * @param {number} offset The offset at which to get notes
         * @param {string} resourceId The id which the notes belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotes: async (limit: number, offset: number, resourceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('getNotes', 'limit', limit)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('getNotes', 'offset', offset)
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('getNotes', 'resourceId', resourceId)
            const localVarPath = `/notes`
                .replace(`{${"limit"}}`, encodeURIComponent(String(limit)))
                .replace(`{${"offset"}}`, encodeURIComponent(String(offset)))
                .replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single note using its id
         * @summary Get Note
         * @param {string} id The id of the note to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotesNote: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNotesNote', 'id', id)
            const localVarPath = `/notes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Note which can be associated with any resource as required.
         * @summary Creates a Note
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNotes: async (uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/notes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Note associated with some resource
         * @summary Updates a Note
         * @param {string} id The id of the Note to update
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNotesNote: async (id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postNotesNote', 'id', id)
            const localVarPath = `/notes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NoteApi - functional programming interface
 * @export
 */
export const NoteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NoteApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a Note.
         * @summary Deletes a Note
         * @param {string} id The id of the Note to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNotesNote(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNotesNote(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of notes
         * @summary List Notes
         * @param {number} limit The number of notes to get
         * @param {number} offset The offset at which to get notes
         * @param {string} resourceId The id which the notes belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotes(limit: number, offset: number, resourceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotes(limit, offset, resourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a single note using its id
         * @summary Get Note
         * @param {string} id The id of the note to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotesNote(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotesNote(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Note which can be associated with any resource as required.
         * @summary Creates a Note
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postNotes(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postNotes(uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a Note associated with some resource
         * @summary Updates a Note
         * @param {string} id The id of the Note to update
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postNotesNote(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postNotesNote(id, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NoteApi - factory interface
 * @export
 */
export const NoteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NoteApiFp(configuration)
    return {
        /**
         * Deletes a Note.
         * @summary Deletes a Note
         * @param {string} id The id of the Note to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotesNote(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteNotesNote(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of notes
         * @summary List Notes
         * @param {number} limit The number of notes to get
         * @param {number} offset The offset at which to get notes
         * @param {string} resourceId The id which the notes belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotes(limit: number, offset: number, resourceId: string, options?: any): AxiosPromise<object> {
            return localVarFp.getNotes(limit, offset, resourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single note using its id
         * @summary Get Note
         * @param {string} id The id of the note to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotesNote(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.getNotesNote(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Note which can be associated with any resource as required.
         * @summary Creates a Note
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNotes(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postNotes(uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a Note associated with some resource
         * @summary Updates a Note
         * @param {string} id The id of the Note to update
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNotesNote(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postNotesNote(id, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NoteApi - object-oriented interface
 * @export
 * @class NoteApi
 * @extends {BaseAPI}
 */
export class NoteApi extends BaseAPI {
    /**
     * Deletes a Note.
     * @summary Deletes a Note
     * @param {string} id The id of the Note to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NoteApi
     */
    public deleteNotesNote(id: string, options?: AxiosRequestConfig) {
        return NoteApiFp(this.configuration).deleteNotesNote(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of notes
     * @summary List Notes
     * @param {number} limit The number of notes to get
     * @param {number} offset The offset at which to get notes
     * @param {string} resourceId The id which the notes belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NoteApi
     */
    public getNotes(limit: number, offset: number, resourceId: string, options?: AxiosRequestConfig) {
        return NoteApiFp(this.configuration).getNotes(limit, offset, resourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single note using its id
     * @summary Get Note
     * @param {string} id The id of the note to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NoteApi
     */
    public getNotesNote(id: string, options?: AxiosRequestConfig) {
        return NoteApiFp(this.configuration).getNotesNote(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Note which can be associated with any resource as required.
     * @summary Creates a Note
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NoteApi
     */
    public postNotes(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return NoteApiFp(this.configuration).postNotes(uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a Note associated with some resource
     * @summary Updates a Note
     * @param {string} id The id of the Note to update
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NoteApi
     */
    public postNotesNote(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return NoteApiFp(this.configuration).postNotesNote(id, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotificationApi - axios parameter creator
 * @export
 */
export const NotificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of Notifications.
         * @summary List Notifications
         * @param {number} [offset] The number of notifications to skip before starting to collect the notifications set
         * @param {number} [limit] The number of notifications to return
         * @param {string} [fields] The fields to include in the result set
         * @param {string} [expand] The fields to populate
         * @param {string} [eventName] 
         * @param {string} [resourceType] 
         * @param {string} [resourceId] 
         * @param {string} [to] 
         * @param {boolean} [includeResends] Whether the result set should include resent notifications or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications: async (offset?: number, limit?: number, fields?: string, expand?: string, eventName?: string, resourceType?: string, resourceId?: string, to?: string, includeResends?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (eventName !== undefined) {
                localVarQueryParameter['event_name'] = eventName;
            }

            if (resourceType !== undefined) {
                localVarQueryParameter['resource_type'] = resourceType;
            }

            if (resourceId !== undefined) {
                localVarQueryParameter['resource_id'] = resourceId;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (includeResends !== undefined) {
                localVarQueryParameter['include_resends'] = includeResends;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resends a previously sent notifications, with the same data but optionally to a different address
         * @summary Resend Notification
         * @param {string} id The id of the Notification
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNotificationsNotificationResend: async (id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postNotificationsNotificationResend', 'id', id)
            const localVarPath = `/notifications/{id}/resend`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationApi - functional programming interface
 * @export
 */
export const NotificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a list of Notifications.
         * @summary List Notifications
         * @param {number} [offset] The number of notifications to skip before starting to collect the notifications set
         * @param {number} [limit] The number of notifications to return
         * @param {string} [fields] The fields to include in the result set
         * @param {string} [expand] The fields to populate
         * @param {string} [eventName] 
         * @param {string} [resourceType] 
         * @param {string} [resourceId] 
         * @param {string} [to] 
         * @param {boolean} [includeResends] Whether the result set should include resent notifications or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotifications(offset?: number, limit?: number, fields?: string, expand?: string, eventName?: string, resourceType?: string, resourceId?: string, to?: string, includeResends?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotifications(offset, limit, fields, expand, eventName, resourceType, resourceId, to, includeResends, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resends a previously sent notifications, with the same data but optionally to a different address
         * @summary Resend Notification
         * @param {string} id The id of the Notification
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postNotificationsNotificationResend(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postNotificationsNotificationResend(id, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotificationApi - factory interface
 * @export
 */
export const NotificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationApiFp(configuration)
    return {
        /**
         * Retrieves a list of Notifications.
         * @summary List Notifications
         * @param {number} [offset] The number of notifications to skip before starting to collect the notifications set
         * @param {number} [limit] The number of notifications to return
         * @param {string} [fields] The fields to include in the result set
         * @param {string} [expand] The fields to populate
         * @param {string} [eventName] 
         * @param {string} [resourceType] 
         * @param {string} [resourceId] 
         * @param {string} [to] 
         * @param {boolean} [includeResends] Whether the result set should include resent notifications or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications(offset?: number, limit?: number, fields?: string, expand?: string, eventName?: string, resourceType?: string, resourceId?: string, to?: string, includeResends?: boolean, options?: any): AxiosPromise<object> {
            return localVarFp.getNotifications(offset, limit, fields, expand, eventName, resourceType, resourceId, to, includeResends, options).then((request) => request(axios, basePath));
        },
        /**
         * Resends a previously sent notifications, with the same data but optionally to a different address
         * @summary Resend Notification
         * @param {string} id The id of the Notification
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNotificationsNotificationResend(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postNotificationsNotificationResend(id, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationApi - object-oriented interface
 * @export
 * @class NotificationApi
 * @extends {BaseAPI}
 */
export class NotificationApi extends BaseAPI {
    /**
     * Retrieves a list of Notifications.
     * @summary List Notifications
     * @param {number} [offset] The number of notifications to skip before starting to collect the notifications set
     * @param {number} [limit] The number of notifications to return
     * @param {string} [fields] The fields to include in the result set
     * @param {string} [expand] The fields to populate
     * @param {string} [eventName] 
     * @param {string} [resourceType] 
     * @param {string} [resourceId] 
     * @param {string} [to] 
     * @param {boolean} [includeResends] Whether the result set should include resent notifications or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public getNotifications(offset?: number, limit?: number, fields?: string, expand?: string, eventName?: string, resourceType?: string, resourceId?: string, to?: string, includeResends?: boolean, options?: AxiosRequestConfig) {
        return NotificationApiFp(this.configuration).getNotifications(offset, limit, fields, expand, eventName, resourceType, resourceId, to, includeResends, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resends a previously sent notifications, with the same data but optionally to a different address
     * @summary Resend Notification
     * @param {string} id The id of the Notification
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public postNotificationsNotificationResend(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return NotificationApiFp(this.configuration).postNotificationsNotificationResend(id, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrderApi - axios parameter creator
 * @export
 */
export const OrderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a metadata key.
         * @summary Delete Metadata
         * @param {string} id The id of the Order.
         * @param {string} key The metadata key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrdersOrderMetadataKey: async (id: string, key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOrdersOrderMetadataKey', 'id', id)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('deleteOrdersOrderMetadataKey', 'key', key)
            const localVarPath = `/order/{id}/metadata/{key}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of Orders
         * @summary List Orders
         * @param {string} [q] Query used for searching orders.
         * @param {string} [id] Id of the order to search for.
         * @param {Array<string>} [status] Status to search for
         * @param {string} [fulfillmentStatus] Fulfillment status to search for.
         * @param {string} [paymentStatus] Payment status to search for.
         * @param {string} [displayId] Display id to search for.
         * @param {string} [cartId] to search for.
         * @param {string} [customerId] to search for.
         * @param {string} [email] to search for.
         * @param {string} [regionId] to search for.
         * @param {string} [currencyCode] to search for.
         * @param {string} [taxRate] to search for.
         * @param {object} [cancelledAt] Date comparison for when resulting orders was cancelled, i.e. less than, greater than etc.
         * @param {object} [createdAt] Date comparison for when resulting orders was created, i.e. less than, greater than etc.
         * @param {object} [updatedAt] Date comparison for when resulting orders was updated, i.e. less than, greater than etc.
         * @param {string} [offset] How many orders to skip in the result.
         * @param {string} [limit] Limit the number of orders returned.
         * @param {string} [expand] (Comma separated) Which fields should be expanded in each order of the result.
         * @param {string} [fields] (Comma separated) Which fields should be included in each order of the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders: async (q?: string, id?: string, status?: Array<string>, fulfillmentStatus?: string, paymentStatus?: string, displayId?: string, cartId?: string, customerId?: string, email?: string, regionId?: string, currencyCode?: string, taxRate?: string, cancelledAt?: object, createdAt?: object, updatedAt?: object, offset?: string, limit?: string, expand?: string, fields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (status) {
                localVarQueryParameter['status'] = status.join(COLLECTION_FORMATS.csv);
            }

            if (fulfillmentStatus !== undefined) {
                localVarQueryParameter['fulfillment_status'] = fulfillmentStatus;
            }

            if (paymentStatus !== undefined) {
                localVarQueryParameter['payment_status'] = paymentStatus;
            }

            if (displayId !== undefined) {
                localVarQueryParameter['display_id'] = displayId;
            }

            if (cartId !== undefined) {
                localVarQueryParameter['cart_id'] = cartId;
            }

            if (customerId !== undefined) {
                localVarQueryParameter['customer_id'] = customerId;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (currencyCode !== undefined) {
                localVarQueryParameter['currency_code'] = currencyCode;
            }

            if (taxRate !== undefined) {
                localVarQueryParameter['tax_rate'] = taxRate;
            }

            if (cancelledAt !== undefined) {
                localVarQueryParameter['cancelled_at'] = cancelledAt;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves an Order
         * @summary Retrieve an Order
         * @param {string} id The id of the Order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersOrder: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOrdersOrder', 'id', id)
            const localVarPath = `/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of TaxRates
         * @summary List Tax Rates
         * @param {string} [q] Query used for searching orders.
         * @param {string} [id] Id of the order to search for.
         * @param {string} [regionId] to search for.
         * @param {string} [code] to search for.
         * @param {string} [rate] to search for.
         * @param {object} [createdAt] Date comparison for when resulting orders was created, i.e. less than, greater than etc.
         * @param {object} [updatedAt] Date comparison for when resulting orders was updated, i.e. less than, greater than etc.
         * @param {string} [offset] How many orders to skip in the result.
         * @param {string} [limit] Limit the number of orders returned.
         * @param {string} [fields] (Comma separated) Which fields should be included in each order of the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxRates: async (q?: string, id?: string, regionId?: string, code?: string, rate?: string, createdAt?: object, updatedAt?: object, offset?: string, limit?: string, fields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tax-rates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (rate !== undefined) {
                localVarQueryParameter['rate'] = rate;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates and order
         * @summary Create an order
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrders: async (uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates and order
         * @summary Update an order
         * @param {string} id The id of the Order.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrder: async (id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postOrdersOrder', 'id', id)
            const localVarPath = `/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Archives the order with the given id.
         * @summary Archive order
         * @param {string} id The id of the Order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderArchive: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postOrdersOrderArchive', 'id', id)
            const localVarPath = `/orders/{id}/archive`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers an Order as canceled. This triggers a flow that will cancel any created Fulfillments and Payments, may fail if the Payment or Fulfillment Provider is unable to cancel the Payment/Fulfillment.
         * @summary Cancel an Order
         * @param {string} id The id of the Order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderCancel: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postOrdersOrderCancel', 'id', id)
            const localVarPath = `/orders/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Captures all the Payments associated with an Order.
         * @summary Capture an Order
         * @param {string} id The id of the Order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderCapture: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postOrdersOrderCapture', 'id', id)
            const localVarPath = `/orders/{id}/capture`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Claim.
         * @summary Create a Claim
         * @param {string} id The id of the Order.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderClaims: async (id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postOrdersOrderClaims', 'id', id)
            const localVarPath = `/order/{id}/claims`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Claim.
         * @summary Update a Claim
         * @param {string} id The id of the Order.
         * @param {string} claimId The id of the Claim.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderClaimsClaim: async (id: string, claimId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postOrdersOrderClaimsClaim', 'id', id)
            // verify required parameter 'claimId' is not null or undefined
            assertParamExists('postOrdersOrderClaimsClaim', 'claimId', claimId)
            const localVarPath = `/order/{id}/claims/{claim_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"claim_id"}}`, encodeURIComponent(String(claimId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Fulfillment for a Claim.
         * @summary Create a Claim Fulfillment
         * @param {string} id The id of the Order.
         * @param {string} claimId The id of the Claim.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderClaimsClaimFulfillments: async (id: string, claimId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postOrdersOrderClaimsClaimFulfillments', 'id', id)
            // verify required parameter 'claimId' is not null or undefined
            assertParamExists('postOrdersOrderClaimsClaimFulfillments', 'claimId', claimId)
            const localVarPath = `/orders/{id}/claims/{claim_id}/fulfillments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"claim_id"}}`, encodeURIComponent(String(claimId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers a Claim Fulfillment as shipped.
         * @summary Create Claim Shipment
         * @param {string} id The id of the Order.
         * @param {string} claimId The id of the Claim.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderClaimsClaimShipments: async (id: string, claimId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postOrdersOrderClaimsClaimShipments', 'id', id)
            // verify required parameter 'claimId' is not null or undefined
            assertParamExists('postOrdersOrderClaimsClaimShipments', 'claimId', claimId)
            const localVarPath = `/orders/{id}/claims/{claim_id}/shipments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"claim_id"}}`, encodeURIComponent(String(claimId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completes an Order
         * @summary Complete an Order
         * @param {string} id The id of the Order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderComplete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postOrdersOrderComplete', 'id', id)
            const localVarPath = `/orders/{id}/complete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Fulfillment of an Order - will notify Fulfillment Providers to prepare a shipment.
         * @summary Create a Fulfillment
         * @param {string} id The id of the Order.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderFulfillments: async (id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postOrdersOrderFulfillments', 'id', id)
            const localVarPath = `/orders/{id}/fulfillments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Issues a Refund.
         * @summary Create a Refund
         * @param {string} id The id of the Order.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderRefunds: async (id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postOrdersOrderRefunds', 'id', id)
            const localVarPath = `/orders/{id}/refunds`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requests a Return. If applicable a return label will be created and other plugins notified.
         * @summary Request a Return
         * @param {string} id The id of the Order.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderReturns: async (id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postOrdersOrderReturns', 'id', id)
            const localVarPath = `/orders/{id}/returns`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers a Fulfillment as shipped.
         * @summary Create a Shipment
         * @param {string} id The id of the Order.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderShipment: async (id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postOrdersOrderShipment', 'id', id)
            const localVarPath = `/orders/{id}/shipment`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a Shipping Method to an Order. If another Shipping Method exists with the same Shipping Profile, the previous Shipping Method will be replaced.
         * @summary Add a Shipping Method
         * @param {string} id The id of the Order.
         * @param {InlineObject5} [inlineObject5] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderShippingMethods: async (id: string, inlineObject5?: InlineObject5, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postOrdersOrderShippingMethods', 'id', id)
            const localVarPath = `/orders/{id}/shipping-methods`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject5, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Swap. Swaps are used to handle Return of previously purchased goods and Fulfillment of replacements simultaneously.
         * @summary Create a Swap
         * @param {string} id The id of the Order.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderSwaps: async (id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postOrdersOrderSwaps', 'id', id)
            const localVarPath = `/order/{id}/swaps`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Fulfillment for a Swap.
         * @summary Create a Swap Fulfillment
         * @param {string} id The id of the Order.
         * @param {string} swapId The id of the Swap.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderSwapsSwapFulfillments: async (id: string, swapId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postOrdersOrderSwapsSwapFulfillments', 'id', id)
            // verify required parameter 'swapId' is not null or undefined
            assertParamExists('postOrdersOrderSwapsSwapFulfillments', 'swapId', swapId)
            const localVarPath = `/orders/{id}/swaps/{swap_id}/fulfillments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"swap_id"}}`, encodeURIComponent(String(swapId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When there are differences between the returned and shipped Products in a Swap, the difference must be processed. Either a Refund will be issued or a Payment will be captured.
         * @summary Process a Swap difference
         * @param {string} id The id of the Order.
         * @param {string} swapId The id of the Swap.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderSwapsSwapProcessPayment: async (id: string, swapId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postOrdersOrderSwapsSwapProcessPayment', 'id', id)
            // verify required parameter 'swapId' is not null or undefined
            assertParamExists('postOrdersOrderSwapsSwapProcessPayment', 'swapId', swapId)
            const localVarPath = `/orders/{id}/swaps/{swap_id}/process-payment`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"swap_id"}}`, encodeURIComponent(String(swapId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers a Swap Fulfillment as shipped.
         * @summary Create Swap Shipment
         * @param {string} id The id of the Order.
         * @param {string} swapId The id of the Swap.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderSwapsSwapShipments: async (id: string, swapId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postOrdersOrderSwapsSwapShipments', 'id', id)
            // verify required parameter 'swapId' is not null or undefined
            assertParamExists('postOrdersOrderSwapsSwapShipments', 'swapId', swapId)
            const localVarPath = `/orders/{id}/swaps/{swap_id}/shipments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"swap_id"}}`, encodeURIComponent(String(swapId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderApi - functional programming interface
 * @export
 */
export const OrderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrderApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a metadata key.
         * @summary Delete Metadata
         * @param {string} id The id of the Order.
         * @param {string} key The metadata key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrdersOrderMetadataKey(id: string, key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrdersOrderMetadataKey(id, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of Orders
         * @summary List Orders
         * @param {string} [q] Query used for searching orders.
         * @param {string} [id] Id of the order to search for.
         * @param {Array<string>} [status] Status to search for
         * @param {string} [fulfillmentStatus] Fulfillment status to search for.
         * @param {string} [paymentStatus] Payment status to search for.
         * @param {string} [displayId] Display id to search for.
         * @param {string} [cartId] to search for.
         * @param {string} [customerId] to search for.
         * @param {string} [email] to search for.
         * @param {string} [regionId] to search for.
         * @param {string} [currencyCode] to search for.
         * @param {string} [taxRate] to search for.
         * @param {object} [cancelledAt] Date comparison for when resulting orders was cancelled, i.e. less than, greater than etc.
         * @param {object} [createdAt] Date comparison for when resulting orders was created, i.e. less than, greater than etc.
         * @param {object} [updatedAt] Date comparison for when resulting orders was updated, i.e. less than, greater than etc.
         * @param {string} [offset] How many orders to skip in the result.
         * @param {string} [limit] Limit the number of orders returned.
         * @param {string} [expand] (Comma separated) Which fields should be expanded in each order of the result.
         * @param {string} [fields] (Comma separated) Which fields should be included in each order of the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrders(q?: string, id?: string, status?: Array<string>, fulfillmentStatus?: string, paymentStatus?: string, displayId?: string, cartId?: string, customerId?: string, email?: string, regionId?: string, currencyCode?: string, taxRate?: string, cancelledAt?: object, createdAt?: object, updatedAt?: object, offset?: string, limit?: string, expand?: string, fields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrders(q, id, status, fulfillmentStatus, paymentStatus, displayId, cartId, customerId, email, regionId, currencyCode, taxRate, cancelledAt, createdAt, updatedAt, offset, limit, expand, fields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves an Order
         * @summary Retrieve an Order
         * @param {string} id The id of the Order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrdersOrder(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrdersOrder(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of TaxRates
         * @summary List Tax Rates
         * @param {string} [q] Query used for searching orders.
         * @param {string} [id] Id of the order to search for.
         * @param {string} [regionId] to search for.
         * @param {string} [code] to search for.
         * @param {string} [rate] to search for.
         * @param {object} [createdAt] Date comparison for when resulting orders was created, i.e. less than, greater than etc.
         * @param {object} [updatedAt] Date comparison for when resulting orders was updated, i.e. less than, greater than etc.
         * @param {string} [offset] How many orders to skip in the result.
         * @param {string} [limit] Limit the number of orders returned.
         * @param {string} [fields] (Comma separated) Which fields should be included in each order of the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaxRates(q?: string, id?: string, regionId?: string, code?: string, rate?: string, createdAt?: object, updatedAt?: object, offset?: string, limit?: string, fields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaxRates(q, id, regionId, code, rate, createdAt, updatedAt, offset, limit, fields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates and order
         * @summary Create an order
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrders(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postOrders(uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates and order
         * @summary Update an order
         * @param {string} id The id of the Order.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrdersOrder(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postOrdersOrder(id, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Archives the order with the given id.
         * @summary Archive order
         * @param {string} id The id of the Order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrdersOrderArchive(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postOrdersOrderArchive(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Registers an Order as canceled. This triggers a flow that will cancel any created Fulfillments and Payments, may fail if the Payment or Fulfillment Provider is unable to cancel the Payment/Fulfillment.
         * @summary Cancel an Order
         * @param {string} id The id of the Order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrdersOrderCancel(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postOrdersOrderCancel(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Captures all the Payments associated with an Order.
         * @summary Capture an Order
         * @param {string} id The id of the Order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrdersOrderCapture(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postOrdersOrderCapture(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Claim.
         * @summary Create a Claim
         * @param {string} id The id of the Order.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrdersOrderClaims(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postOrdersOrderClaims(id, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a Claim.
         * @summary Update a Claim
         * @param {string} id The id of the Order.
         * @param {string} claimId The id of the Claim.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrdersOrderClaimsClaim(id: string, claimId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postOrdersOrderClaimsClaim(id, claimId, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Fulfillment for a Claim.
         * @summary Create a Claim Fulfillment
         * @param {string} id The id of the Order.
         * @param {string} claimId The id of the Claim.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrdersOrderClaimsClaimFulfillments(id: string, claimId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postOrdersOrderClaimsClaimFulfillments(id, claimId, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Registers a Claim Fulfillment as shipped.
         * @summary Create Claim Shipment
         * @param {string} id The id of the Order.
         * @param {string} claimId The id of the Claim.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrdersOrderClaimsClaimShipments(id: string, claimId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postOrdersOrderClaimsClaimShipments(id, claimId, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Completes an Order
         * @summary Complete an Order
         * @param {string} id The id of the Order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrdersOrderComplete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postOrdersOrderComplete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Fulfillment of an Order - will notify Fulfillment Providers to prepare a shipment.
         * @summary Create a Fulfillment
         * @param {string} id The id of the Order.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrdersOrderFulfillments(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postOrdersOrderFulfillments(id, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Issues a Refund.
         * @summary Create a Refund
         * @param {string} id The id of the Order.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrdersOrderRefunds(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postOrdersOrderRefunds(id, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Requests a Return. If applicable a return label will be created and other plugins notified.
         * @summary Request a Return
         * @param {string} id The id of the Order.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrdersOrderReturns(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postOrdersOrderReturns(id, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Registers a Fulfillment as shipped.
         * @summary Create a Shipment
         * @param {string} id The id of the Order.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrdersOrderShipment(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postOrdersOrderShipment(id, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a Shipping Method to an Order. If another Shipping Method exists with the same Shipping Profile, the previous Shipping Method will be replaced.
         * @summary Add a Shipping Method
         * @param {string} id The id of the Order.
         * @param {InlineObject5} [inlineObject5] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrdersOrderShippingMethods(id: string, inlineObject5?: InlineObject5, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postOrdersOrderShippingMethods(id, inlineObject5, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Swap. Swaps are used to handle Return of previously purchased goods and Fulfillment of replacements simultaneously.
         * @summary Create a Swap
         * @param {string} id The id of the Order.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrdersOrderSwaps(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postOrdersOrderSwaps(id, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Fulfillment for a Swap.
         * @summary Create a Swap Fulfillment
         * @param {string} id The id of the Order.
         * @param {string} swapId The id of the Swap.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrdersOrderSwapsSwapFulfillments(id: string, swapId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postOrdersOrderSwapsSwapFulfillments(id, swapId, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * When there are differences between the returned and shipped Products in a Swap, the difference must be processed. Either a Refund will be issued or a Payment will be captured.
         * @summary Process a Swap difference
         * @param {string} id The id of the Order.
         * @param {string} swapId The id of the Swap.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrdersOrderSwapsSwapProcessPayment(id: string, swapId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postOrdersOrderSwapsSwapProcessPayment(id, swapId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Registers a Swap Fulfillment as shipped.
         * @summary Create Swap Shipment
         * @param {string} id The id of the Order.
         * @param {string} swapId The id of the Swap.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrdersOrderSwapsSwapShipments(id: string, swapId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postOrdersOrderSwapsSwapShipments(id, swapId, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrderApi - factory interface
 * @export
 */
export const OrderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrderApiFp(configuration)
    return {
        /**
         * Deletes a metadata key.
         * @summary Delete Metadata
         * @param {string} id The id of the Order.
         * @param {string} key The metadata key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrdersOrderMetadataKey(id: string, key: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteOrdersOrderMetadataKey(id, key, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of Orders
         * @summary List Orders
         * @param {string} [q] Query used for searching orders.
         * @param {string} [id] Id of the order to search for.
         * @param {Array<string>} [status] Status to search for
         * @param {string} [fulfillmentStatus] Fulfillment status to search for.
         * @param {string} [paymentStatus] Payment status to search for.
         * @param {string} [displayId] Display id to search for.
         * @param {string} [cartId] to search for.
         * @param {string} [customerId] to search for.
         * @param {string} [email] to search for.
         * @param {string} [regionId] to search for.
         * @param {string} [currencyCode] to search for.
         * @param {string} [taxRate] to search for.
         * @param {object} [cancelledAt] Date comparison for when resulting orders was cancelled, i.e. less than, greater than etc.
         * @param {object} [createdAt] Date comparison for when resulting orders was created, i.e. less than, greater than etc.
         * @param {object} [updatedAt] Date comparison for when resulting orders was updated, i.e. less than, greater than etc.
         * @param {string} [offset] How many orders to skip in the result.
         * @param {string} [limit] Limit the number of orders returned.
         * @param {string} [expand] (Comma separated) Which fields should be expanded in each order of the result.
         * @param {string} [fields] (Comma separated) Which fields should be included in each order of the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders(q?: string, id?: string, status?: Array<string>, fulfillmentStatus?: string, paymentStatus?: string, displayId?: string, cartId?: string, customerId?: string, email?: string, regionId?: string, currencyCode?: string, taxRate?: string, cancelledAt?: object, createdAt?: object, updatedAt?: object, offset?: string, limit?: string, expand?: string, fields?: string, options?: any): AxiosPromise<object> {
            return localVarFp.getOrders(q, id, status, fulfillmentStatus, paymentStatus, displayId, cartId, customerId, email, regionId, currencyCode, taxRate, cancelledAt, createdAt, updatedAt, offset, limit, expand, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves an Order
         * @summary Retrieve an Order
         * @param {string} id The id of the Order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersOrder(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.getOrdersOrder(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of TaxRates
         * @summary List Tax Rates
         * @param {string} [q] Query used for searching orders.
         * @param {string} [id] Id of the order to search for.
         * @param {string} [regionId] to search for.
         * @param {string} [code] to search for.
         * @param {string} [rate] to search for.
         * @param {object} [createdAt] Date comparison for when resulting orders was created, i.e. less than, greater than etc.
         * @param {object} [updatedAt] Date comparison for when resulting orders was updated, i.e. less than, greater than etc.
         * @param {string} [offset] How many orders to skip in the result.
         * @param {string} [limit] Limit the number of orders returned.
         * @param {string} [fields] (Comma separated) Which fields should be included in each order of the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxRates(q?: string, id?: string, regionId?: string, code?: string, rate?: string, createdAt?: object, updatedAt?: object, offset?: string, limit?: string, fields?: string, options?: any): AxiosPromise<object> {
            return localVarFp.getTaxRates(q, id, regionId, code, rate, createdAt, updatedAt, offset, limit, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates and order
         * @summary Create an order
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrders(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postOrders(uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates and order
         * @summary Update an order
         * @param {string} id The id of the Order.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrder(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postOrdersOrder(id, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Archives the order with the given id.
         * @summary Archive order
         * @param {string} id The id of the Order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderArchive(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.postOrdersOrderArchive(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Registers an Order as canceled. This triggers a flow that will cancel any created Fulfillments and Payments, may fail if the Payment or Fulfillment Provider is unable to cancel the Payment/Fulfillment.
         * @summary Cancel an Order
         * @param {string} id The id of the Order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderCancel(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.postOrdersOrderCancel(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Captures all the Payments associated with an Order.
         * @summary Capture an Order
         * @param {string} id The id of the Order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderCapture(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.postOrdersOrderCapture(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Claim.
         * @summary Create a Claim
         * @param {string} id The id of the Order.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderClaims(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postOrdersOrderClaims(id, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a Claim.
         * @summary Update a Claim
         * @param {string} id The id of the Order.
         * @param {string} claimId The id of the Claim.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderClaimsClaim(id: string, claimId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postOrdersOrderClaimsClaim(id, claimId, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Fulfillment for a Claim.
         * @summary Create a Claim Fulfillment
         * @param {string} id The id of the Order.
         * @param {string} claimId The id of the Claim.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderClaimsClaimFulfillments(id: string, claimId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postOrdersOrderClaimsClaimFulfillments(id, claimId, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Registers a Claim Fulfillment as shipped.
         * @summary Create Claim Shipment
         * @param {string} id The id of the Order.
         * @param {string} claimId The id of the Claim.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderClaimsClaimShipments(id: string, claimId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postOrdersOrderClaimsClaimShipments(id, claimId, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Completes an Order
         * @summary Complete an Order
         * @param {string} id The id of the Order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderComplete(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.postOrdersOrderComplete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Fulfillment of an Order - will notify Fulfillment Providers to prepare a shipment.
         * @summary Create a Fulfillment
         * @param {string} id The id of the Order.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderFulfillments(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postOrdersOrderFulfillments(id, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Issues a Refund.
         * @summary Create a Refund
         * @param {string} id The id of the Order.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderRefunds(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postOrdersOrderRefunds(id, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Requests a Return. If applicable a return label will be created and other plugins notified.
         * @summary Request a Return
         * @param {string} id The id of the Order.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderReturns(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postOrdersOrderReturns(id, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Registers a Fulfillment as shipped.
         * @summary Create a Shipment
         * @param {string} id The id of the Order.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderShipment(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postOrdersOrderShipment(id, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a Shipping Method to an Order. If another Shipping Method exists with the same Shipping Profile, the previous Shipping Method will be replaced.
         * @summary Add a Shipping Method
         * @param {string} id The id of the Order.
         * @param {InlineObject5} [inlineObject5] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderShippingMethods(id: string, inlineObject5?: InlineObject5, options?: any): AxiosPromise<object> {
            return localVarFp.postOrdersOrderShippingMethods(id, inlineObject5, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Swap. Swaps are used to handle Return of previously purchased goods and Fulfillment of replacements simultaneously.
         * @summary Create a Swap
         * @param {string} id The id of the Order.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderSwaps(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postOrdersOrderSwaps(id, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Fulfillment for a Swap.
         * @summary Create a Swap Fulfillment
         * @param {string} id The id of the Order.
         * @param {string} swapId The id of the Swap.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderSwapsSwapFulfillments(id: string, swapId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postOrdersOrderSwapsSwapFulfillments(id, swapId, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * When there are differences between the returned and shipped Products in a Swap, the difference must be processed. Either a Refund will be issued or a Payment will be captured.
         * @summary Process a Swap difference
         * @param {string} id The id of the Order.
         * @param {string} swapId The id of the Swap.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderSwapsSwapProcessPayment(id: string, swapId: string, options?: any): AxiosPromise<object> {
            return localVarFp.postOrdersOrderSwapsSwapProcessPayment(id, swapId, options).then((request) => request(axios, basePath));
        },
        /**
         * Registers a Swap Fulfillment as shipped.
         * @summary Create Swap Shipment
         * @param {string} id The id of the Order.
         * @param {string} swapId The id of the Swap.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderSwapsSwapShipments(id: string, swapId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postOrdersOrderSwapsSwapShipments(id, swapId, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
export class OrderApi extends BaseAPI {
    /**
     * Deletes a metadata key.
     * @summary Delete Metadata
     * @param {string} id The id of the Order.
     * @param {string} key The metadata key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public deleteOrdersOrderMetadataKey(id: string, key: string, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).deleteOrdersOrderMetadataKey(id, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of Orders
     * @summary List Orders
     * @param {string} [q] Query used for searching orders.
     * @param {string} [id] Id of the order to search for.
     * @param {Array<string>} [status] Status to search for
     * @param {string} [fulfillmentStatus] Fulfillment status to search for.
     * @param {string} [paymentStatus] Payment status to search for.
     * @param {string} [displayId] Display id to search for.
     * @param {string} [cartId] to search for.
     * @param {string} [customerId] to search for.
     * @param {string} [email] to search for.
     * @param {string} [regionId] to search for.
     * @param {string} [currencyCode] to search for.
     * @param {string} [taxRate] to search for.
     * @param {object} [cancelledAt] Date comparison for when resulting orders was cancelled, i.e. less than, greater than etc.
     * @param {object} [createdAt] Date comparison for when resulting orders was created, i.e. less than, greater than etc.
     * @param {object} [updatedAt] Date comparison for when resulting orders was updated, i.e. less than, greater than etc.
     * @param {string} [offset] How many orders to skip in the result.
     * @param {string} [limit] Limit the number of orders returned.
     * @param {string} [expand] (Comma separated) Which fields should be expanded in each order of the result.
     * @param {string} [fields] (Comma separated) Which fields should be included in each order of the result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getOrders(q?: string, id?: string, status?: Array<string>, fulfillmentStatus?: string, paymentStatus?: string, displayId?: string, cartId?: string, customerId?: string, email?: string, regionId?: string, currencyCode?: string, taxRate?: string, cancelledAt?: object, createdAt?: object, updatedAt?: object, offset?: string, limit?: string, expand?: string, fields?: string, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).getOrders(q, id, status, fulfillmentStatus, paymentStatus, displayId, cartId, customerId, email, regionId, currencyCode, taxRate, cancelledAt, createdAt, updatedAt, offset, limit, expand, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves an Order
     * @summary Retrieve an Order
     * @param {string} id The id of the Order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getOrdersOrder(id: string, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).getOrdersOrder(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of TaxRates
     * @summary List Tax Rates
     * @param {string} [q] Query used for searching orders.
     * @param {string} [id] Id of the order to search for.
     * @param {string} [regionId] to search for.
     * @param {string} [code] to search for.
     * @param {string} [rate] to search for.
     * @param {object} [createdAt] Date comparison for when resulting orders was created, i.e. less than, greater than etc.
     * @param {object} [updatedAt] Date comparison for when resulting orders was updated, i.e. less than, greater than etc.
     * @param {string} [offset] How many orders to skip in the result.
     * @param {string} [limit] Limit the number of orders returned.
     * @param {string} [fields] (Comma separated) Which fields should be included in each order of the result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getTaxRates(q?: string, id?: string, regionId?: string, code?: string, rate?: string, createdAt?: object, updatedAt?: object, offset?: string, limit?: string, fields?: string, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).getTaxRates(q, id, regionId, code, rate, createdAt, updatedAt, offset, limit, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates and order
     * @summary Create an order
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public postOrders(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).postOrders(uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates and order
     * @summary Update an order
     * @param {string} id The id of the Order.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public postOrdersOrder(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).postOrdersOrder(id, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Archives the order with the given id.
     * @summary Archive order
     * @param {string} id The id of the Order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public postOrdersOrderArchive(id: string, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).postOrdersOrderArchive(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registers an Order as canceled. This triggers a flow that will cancel any created Fulfillments and Payments, may fail if the Payment or Fulfillment Provider is unable to cancel the Payment/Fulfillment.
     * @summary Cancel an Order
     * @param {string} id The id of the Order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public postOrdersOrderCancel(id: string, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).postOrdersOrderCancel(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Captures all the Payments associated with an Order.
     * @summary Capture an Order
     * @param {string} id The id of the Order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public postOrdersOrderCapture(id: string, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).postOrdersOrderCapture(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Claim.
     * @summary Create a Claim
     * @param {string} id The id of the Order.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public postOrdersOrderClaims(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).postOrdersOrderClaims(id, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a Claim.
     * @summary Update a Claim
     * @param {string} id The id of the Order.
     * @param {string} claimId The id of the Claim.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public postOrdersOrderClaimsClaim(id: string, claimId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).postOrdersOrderClaimsClaim(id, claimId, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Fulfillment for a Claim.
     * @summary Create a Claim Fulfillment
     * @param {string} id The id of the Order.
     * @param {string} claimId The id of the Claim.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public postOrdersOrderClaimsClaimFulfillments(id: string, claimId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).postOrdersOrderClaimsClaimFulfillments(id, claimId, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registers a Claim Fulfillment as shipped.
     * @summary Create Claim Shipment
     * @param {string} id The id of the Order.
     * @param {string} claimId The id of the Claim.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public postOrdersOrderClaimsClaimShipments(id: string, claimId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).postOrdersOrderClaimsClaimShipments(id, claimId, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Completes an Order
     * @summary Complete an Order
     * @param {string} id The id of the Order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public postOrdersOrderComplete(id: string, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).postOrdersOrderComplete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Fulfillment of an Order - will notify Fulfillment Providers to prepare a shipment.
     * @summary Create a Fulfillment
     * @param {string} id The id of the Order.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public postOrdersOrderFulfillments(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).postOrdersOrderFulfillments(id, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Issues a Refund.
     * @summary Create a Refund
     * @param {string} id The id of the Order.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public postOrdersOrderRefunds(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).postOrdersOrderRefunds(id, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requests a Return. If applicable a return label will be created and other plugins notified.
     * @summary Request a Return
     * @param {string} id The id of the Order.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public postOrdersOrderReturns(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).postOrdersOrderReturns(id, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registers a Fulfillment as shipped.
     * @summary Create a Shipment
     * @param {string} id The id of the Order.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public postOrdersOrderShipment(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).postOrdersOrderShipment(id, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a Shipping Method to an Order. If another Shipping Method exists with the same Shipping Profile, the previous Shipping Method will be replaced.
     * @summary Add a Shipping Method
     * @param {string} id The id of the Order.
     * @param {InlineObject5} [inlineObject5] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public postOrdersOrderShippingMethods(id: string, inlineObject5?: InlineObject5, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).postOrdersOrderShippingMethods(id, inlineObject5, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Swap. Swaps are used to handle Return of previously purchased goods and Fulfillment of replacements simultaneously.
     * @summary Create a Swap
     * @param {string} id The id of the Order.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public postOrdersOrderSwaps(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).postOrdersOrderSwaps(id, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Fulfillment for a Swap.
     * @summary Create a Swap Fulfillment
     * @param {string} id The id of the Order.
     * @param {string} swapId The id of the Swap.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public postOrdersOrderSwapsSwapFulfillments(id: string, swapId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).postOrdersOrderSwapsSwapFulfillments(id, swapId, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When there are differences between the returned and shipped Products in a Swap, the difference must be processed. Either a Refund will be issued or a Payment will be captured.
     * @summary Process a Swap difference
     * @param {string} id The id of the Order.
     * @param {string} swapId The id of the Swap.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public postOrdersOrderSwapsSwapProcessPayment(id: string, swapId: string, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).postOrdersOrderSwapsSwapProcessPayment(id, swapId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registers a Swap Fulfillment as shipped.
     * @summary Create Swap Shipment
     * @param {string} id The id of the Order.
     * @param {string} swapId The id of the Swap.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public postOrdersOrderSwapsSwapShipments(id: string, swapId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).postOrdersOrderSwapsSwapShipments(id, swapId, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductApi - axios parameter creator
 * @export
 */
export const ProductApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a Product and it\'s associated Product Variants.
         * @summary Delete a Product
         * @param {string} id The id of the Product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProduct: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProductsProduct', 'id', id)
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a Product Option. Before a Product Option can be deleted all Option Values for the Product Option must be the same. You may, for example, have to delete some of your variants prior to deleting the Product Option
         * @summary Delete a Product Option
         * @param {string} id The id of the Product.
         * @param {string} optionId The id of the Product Option.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductOptionsOption: async (id: string, optionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProductsProductOptionsOption', 'id', id)
            // verify required parameter 'optionId' is not null or undefined
            assertParamExists('deleteProductsProductOptionsOption', 'optionId', optionId)
            const localVarPath = `/products/{id}/options/{option_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"option_id"}}`, encodeURIComponent(String(optionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a Product Variant.
         * @summary Delete a Product Variant
         * @param {string} id The id of the Product.
         * @param {string} variantId The id of the Product Variant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductVariantsVariant: async (id: string, variantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProductsProductVariantsVariant', 'id', id)
            // verify required parameter 'variantId' is not null or undefined
            assertParamExists('deleteProductsProductVariantsVariant', 'variantId', variantId)
            const localVarPath = `/products/{id}/variants/{variant_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"variant_id"}}`, encodeURIComponent(String(variantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of Product
         * @summary List Product
         * @param {string} [q] Query used for searching products.
         * @param {string} [id] Id of the product to search for.
         * @param {Array<string>} [status] Status to search for
         * @param {Array<string>} [collectionId] Collection ids to search for.
         * @param {Array<string>} [tags] Tags to search for
         * @param {string} [title] to search for.
         * @param {string} [description] to search for.
         * @param {string} [handle] to search for.
         * @param {string} [isGiftcard] Search for giftcards using is_giftcard&#x3D;true.
         * @param {string} [type] to search for.
         * @param {string} [order] to retrieve products in.
         * @param {object} [deletedAt] Date comparison for when resulting products was deleted, i.e. less than, greater than etc.
         * @param {object} [createdAt] Date comparison for when resulting products was created, i.e. less than, greater than etc.
         * @param {object} [updatedAt] Date comparison for when resulting products was updated, i.e. less than, greater than etc.
         * @param {string} [offset] How many products to skip in the result.
         * @param {string} [limit] Limit the number of products returned.
         * @param {string} [expand] (Comma separated) Which fields should be expanded in each product of the result.
         * @param {string} [fields] (Comma separated) Which fields should be included in each product of the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts: async (q?: string, id?: string, status?: Array<string>, collectionId?: Array<string>, tags?: Array<string>, title?: string, description?: string, handle?: string, isGiftcard?: string, type?: string, order?: string, deletedAt?: object, createdAt?: object, updatedAt?: object, offset?: string, limit?: string, expand?: string, fields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (status) {
                localVarQueryParameter['status'] = status.join(COLLECTION_FORMATS.csv);
            }

            if (collectionId) {
                localVarQueryParameter['collection_id'] = collectionId.join(COLLECTION_FORMATS.csv);
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags.join(COLLECTION_FORMATS.csv);
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (handle !== undefined) {
                localVarQueryParameter['handle'] = handle;
            }

            if (isGiftcard !== undefined) {
                localVarQueryParameter['is_giftcard'] = isGiftcard;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (deletedAt !== undefined) {
                localVarQueryParameter['deleted_at'] = deletedAt;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Product.
         * @summary Retrieve a Product
         * @param {string} id The id of the Product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsProduct: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProductsProduct', 'id', id)
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of the Product Variants associated with a Product.
         * @summary List a Product\'s Product Variants
         * @param {string} id The id of the Product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsProductVariants: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProductsProductVariants', 'id', id)
            const localVarPath = `/products/{id}/variants`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of Product Types.
         * @summary List Product Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsTypes: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Product
         * @summary Create a Product
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProducts: async (uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Product
         * @summary Update a Product
         * @param {string} id The id of the Product.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProduct: async (id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postProductsProduct', 'id', id)
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set metadata key/value pair for Product
         * @summary Set Product metadata
         * @param {string} id The id of the Product.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductMetadata: async (id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postProductsProductMetadata', 'id', id)
            const localVarPath = `/products/{id}/metadata`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a Product Option to a Product
         * @summary Add an Option
         * @param {string} id The id of the Product.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductOptions: async (id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postProductsProductOptions', 'id', id)
            const localVarPath = `/products/{id}/options`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Product Option
         * @summary Update a Product Option.
         * @param {string} id The id of the Product.
         * @param {string} optionId The id of the Product Option.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductOptionsOption: async (id: string, optionId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postProductsProductOptionsOption', 'id', id)
            // verify required parameter 'optionId' is not null or undefined
            assertParamExists('postProductsProductOptionsOption', 'optionId', optionId)
            const localVarPath = `/products/{id}/options/{option_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"option_id"}}`, encodeURIComponent(String(optionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Product Variant. Each Product Variant must have a unique combination of Product Option Values.
         * @summary Create a Product Variant
         * @param {string} id The id of the Product.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductVariants: async (id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postProductsProductVariants', 'id', id)
            const localVarPath = `/products/{id}/variants`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Product Variant.
         * @summary Update a Product Variant
         * @param {string} id The id of the Product.
         * @param {string} variantId The id of the Product Variant.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductVariantsVariant: async (id: string, variantId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postProductsProductVariantsVariant', 'id', id)
            // verify required parameter 'variantId' is not null or undefined
            assertParamExists('postProductsProductVariantsVariant', 'variantId', variantId)
            const localVarPath = `/products/{id}/variants/{variant_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"variant_id"}}`, encodeURIComponent(String(variantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a Product and it\'s associated Product Variants.
         * @summary Delete a Product
         * @param {string} id The id of the Product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProductsProduct(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProductsProduct(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a Product Option. Before a Product Option can be deleted all Option Values for the Product Option must be the same. You may, for example, have to delete some of your variants prior to deleting the Product Option
         * @summary Delete a Product Option
         * @param {string} id The id of the Product.
         * @param {string} optionId The id of the Product Option.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProductsProductOptionsOption(id: string, optionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProductsProductOptionsOption(id, optionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a Product Variant.
         * @summary Delete a Product Variant
         * @param {string} id The id of the Product.
         * @param {string} variantId The id of the Product Variant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProductsProductVariantsVariant(id: string, variantId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProductsProductVariantsVariant(id, variantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of Product
         * @summary List Product
         * @param {string} [q] Query used for searching products.
         * @param {string} [id] Id of the product to search for.
         * @param {Array<string>} [status] Status to search for
         * @param {Array<string>} [collectionId] Collection ids to search for.
         * @param {Array<string>} [tags] Tags to search for
         * @param {string} [title] to search for.
         * @param {string} [description] to search for.
         * @param {string} [handle] to search for.
         * @param {string} [isGiftcard] Search for giftcards using is_giftcard&#x3D;true.
         * @param {string} [type] to search for.
         * @param {string} [order] to retrieve products in.
         * @param {object} [deletedAt] Date comparison for when resulting products was deleted, i.e. less than, greater than etc.
         * @param {object} [createdAt] Date comparison for when resulting products was created, i.e. less than, greater than etc.
         * @param {object} [updatedAt] Date comparison for when resulting products was updated, i.e. less than, greater than etc.
         * @param {string} [offset] How many products to skip in the result.
         * @param {string} [limit] Limit the number of products returned.
         * @param {string} [expand] (Comma separated) Which fields should be expanded in each product of the result.
         * @param {string} [fields] (Comma separated) Which fields should be included in each product of the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProducts(q?: string, id?: string, status?: Array<string>, collectionId?: Array<string>, tags?: Array<string>, title?: string, description?: string, handle?: string, isGiftcard?: string, type?: string, order?: string, deletedAt?: object, createdAt?: object, updatedAt?: object, offset?: string, limit?: string, expand?: string, fields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProducts(q, id, status, collectionId, tags, title, description, handle, isGiftcard, type, order, deletedAt, createdAt, updatedAt, offset, limit, expand, fields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a Product.
         * @summary Retrieve a Product
         * @param {string} id The id of the Product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductsProduct(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductsProduct(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of the Product Variants associated with a Product.
         * @summary List a Product\'s Product Variants
         * @param {string} id The id of the Product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductsProductVariants(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductsProductVariants(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of Product Types.
         * @summary List Product Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductsTypes(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductsTypes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Product
         * @summary Create a Product
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProducts(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postProducts(uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a Product
         * @summary Update a Product
         * @param {string} id The id of the Product.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProductsProduct(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postProductsProduct(id, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set metadata key/value pair for Product
         * @summary Set Product metadata
         * @param {string} id The id of the Product.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProductsProductMetadata(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postProductsProductMetadata(id, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a Product Option to a Product
         * @summary Add an Option
         * @param {string} id The id of the Product.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProductsProductOptions(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postProductsProductOptions(id, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a Product Option
         * @summary Update a Product Option.
         * @param {string} id The id of the Product.
         * @param {string} optionId The id of the Product Option.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProductsProductOptionsOption(id: string, optionId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postProductsProductOptionsOption(id, optionId, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Product Variant. Each Product Variant must have a unique combination of Product Option Values.
         * @summary Create a Product Variant
         * @param {string} id The id of the Product.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProductsProductVariants(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postProductsProductVariants(id, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a Product Variant.
         * @summary Update a Product Variant
         * @param {string} id The id of the Product.
         * @param {string} variantId The id of the Product Variant.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProductsProductVariantsVariant(id: string, variantId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postProductsProductVariantsVariant(id, variantId, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductApiFp(configuration)
    return {
        /**
         * Deletes a Product and it\'s associated Product Variants.
         * @summary Delete a Product
         * @param {string} id The id of the Product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProduct(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteProductsProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a Product Option. Before a Product Option can be deleted all Option Values for the Product Option must be the same. You may, for example, have to delete some of your variants prior to deleting the Product Option
         * @summary Delete a Product Option
         * @param {string} id The id of the Product.
         * @param {string} optionId The id of the Product Option.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductOptionsOption(id: string, optionId: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteProductsProductOptionsOption(id, optionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a Product Variant.
         * @summary Delete a Product Variant
         * @param {string} id The id of the Product.
         * @param {string} variantId The id of the Product Variant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductVariantsVariant(id: string, variantId: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteProductsProductVariantsVariant(id, variantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of Product
         * @summary List Product
         * @param {string} [q] Query used for searching products.
         * @param {string} [id] Id of the product to search for.
         * @param {Array<string>} [status] Status to search for
         * @param {Array<string>} [collectionId] Collection ids to search for.
         * @param {Array<string>} [tags] Tags to search for
         * @param {string} [title] to search for.
         * @param {string} [description] to search for.
         * @param {string} [handle] to search for.
         * @param {string} [isGiftcard] Search for giftcards using is_giftcard&#x3D;true.
         * @param {string} [type] to search for.
         * @param {string} [order] to retrieve products in.
         * @param {object} [deletedAt] Date comparison for when resulting products was deleted, i.e. less than, greater than etc.
         * @param {object} [createdAt] Date comparison for when resulting products was created, i.e. less than, greater than etc.
         * @param {object} [updatedAt] Date comparison for when resulting products was updated, i.e. less than, greater than etc.
         * @param {string} [offset] How many products to skip in the result.
         * @param {string} [limit] Limit the number of products returned.
         * @param {string} [expand] (Comma separated) Which fields should be expanded in each product of the result.
         * @param {string} [fields] (Comma separated) Which fields should be included in each product of the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts(q?: string, id?: string, status?: Array<string>, collectionId?: Array<string>, tags?: Array<string>, title?: string, description?: string, handle?: string, isGiftcard?: string, type?: string, order?: string, deletedAt?: object, createdAt?: object, updatedAt?: object, offset?: string, limit?: string, expand?: string, fields?: string, options?: any): AxiosPromise<object> {
            return localVarFp.getProducts(q, id, status, collectionId, tags, title, description, handle, isGiftcard, type, order, deletedAt, createdAt, updatedAt, offset, limit, expand, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Product.
         * @summary Retrieve a Product
         * @param {string} id The id of the Product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsProduct(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.getProductsProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of the Product Variants associated with a Product.
         * @summary List a Product\'s Product Variants
         * @param {string} id The id of the Product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsProductVariants(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.getProductsProductVariants(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of Product Types.
         * @summary List Product Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsTypes(options?: any): AxiosPromise<object> {
            return localVarFp.getProductsTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Product
         * @summary Create a Product
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProducts(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postProducts(uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a Product
         * @summary Update a Product
         * @param {string} id The id of the Product.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProduct(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postProductsProduct(id, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Set metadata key/value pair for Product
         * @summary Set Product metadata
         * @param {string} id The id of the Product.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductMetadata(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postProductsProductMetadata(id, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a Product Option to a Product
         * @summary Add an Option
         * @param {string} id The id of the Product.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductOptions(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postProductsProductOptions(id, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a Product Option
         * @summary Update a Product Option.
         * @param {string} id The id of the Product.
         * @param {string} optionId The id of the Product Option.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductOptionsOption(id: string, optionId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postProductsProductOptionsOption(id, optionId, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Product Variant. Each Product Variant must have a unique combination of Product Option Values.
         * @summary Create a Product Variant
         * @param {string} id The id of the Product.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductVariants(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postProductsProductVariants(id, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Product Variant.
         * @summary Update a Product Variant
         * @param {string} id The id of the Product.
         * @param {string} variantId The id of the Product Variant.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductVariantsVariant(id: string, variantId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postProductsProductVariantsVariant(id, variantId, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
    /**
     * Deletes a Product and it\'s associated Product Variants.
     * @summary Delete a Product
     * @param {string} id The id of the Product.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public deleteProductsProduct(id: string, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).deleteProductsProduct(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a Product Option. Before a Product Option can be deleted all Option Values for the Product Option must be the same. You may, for example, have to delete some of your variants prior to deleting the Product Option
     * @summary Delete a Product Option
     * @param {string} id The id of the Product.
     * @param {string} optionId The id of the Product Option.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public deleteProductsProductOptionsOption(id: string, optionId: string, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).deleteProductsProductOptionsOption(id, optionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a Product Variant.
     * @summary Delete a Product Variant
     * @param {string} id The id of the Product.
     * @param {string} variantId The id of the Product Variant.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public deleteProductsProductVariantsVariant(id: string, variantId: string, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).deleteProductsProductVariantsVariant(id, variantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of Product
     * @summary List Product
     * @param {string} [q] Query used for searching products.
     * @param {string} [id] Id of the product to search for.
     * @param {Array<string>} [status] Status to search for
     * @param {Array<string>} [collectionId] Collection ids to search for.
     * @param {Array<string>} [tags] Tags to search for
     * @param {string} [title] to search for.
     * @param {string} [description] to search for.
     * @param {string} [handle] to search for.
     * @param {string} [isGiftcard] Search for giftcards using is_giftcard&#x3D;true.
     * @param {string} [type] to search for.
     * @param {string} [order] to retrieve products in.
     * @param {object} [deletedAt] Date comparison for when resulting products was deleted, i.e. less than, greater than etc.
     * @param {object} [createdAt] Date comparison for when resulting products was created, i.e. less than, greater than etc.
     * @param {object} [updatedAt] Date comparison for when resulting products was updated, i.e. less than, greater than etc.
     * @param {string} [offset] How many products to skip in the result.
     * @param {string} [limit] Limit the number of products returned.
     * @param {string} [expand] (Comma separated) Which fields should be expanded in each product of the result.
     * @param {string} [fields] (Comma separated) Which fields should be included in each product of the result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProducts(q?: string, id?: string, status?: Array<string>, collectionId?: Array<string>, tags?: Array<string>, title?: string, description?: string, handle?: string, isGiftcard?: string, type?: string, order?: string, deletedAt?: object, createdAt?: object, updatedAt?: object, offset?: string, limit?: string, expand?: string, fields?: string, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).getProducts(q, id, status, collectionId, tags, title, description, handle, isGiftcard, type, order, deletedAt, createdAt, updatedAt, offset, limit, expand, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Product.
     * @summary Retrieve a Product
     * @param {string} id The id of the Product.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProductsProduct(id: string, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).getProductsProduct(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of the Product Variants associated with a Product.
     * @summary List a Product\'s Product Variants
     * @param {string} id The id of the Product.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProductsProductVariants(id: string, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).getProductsProductVariants(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of Product Types.
     * @summary List Product Types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProductsTypes(options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).getProductsTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Product
     * @summary Create a Product
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public postProducts(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).postProducts(uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a Product
     * @summary Update a Product
     * @param {string} id The id of the Product.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public postProductsProduct(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).postProductsProduct(id, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set metadata key/value pair for Product
     * @summary Set Product metadata
     * @param {string} id The id of the Product.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public postProductsProductMetadata(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).postProductsProductMetadata(id, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a Product Option to a Product
     * @summary Add an Option
     * @param {string} id The id of the Product.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public postProductsProductOptions(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).postProductsProductOptions(id, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a Product Option
     * @summary Update a Product Option.
     * @param {string} id The id of the Product.
     * @param {string} optionId The id of the Product Option.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public postProductsProductOptionsOption(id: string, optionId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).postProductsProductOptionsOption(id, optionId, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Product Variant. Each Product Variant must have a unique combination of Product Option Values.
     * @summary Create a Product Variant
     * @param {string} id The id of the Product.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public postProductsProductVariants(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).postProductsProductVariants(id, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Product Variant.
     * @summary Update a Product Variant
     * @param {string} id The id of the Product.
     * @param {string} variantId The id of the Product Variant.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public postProductsProductVariantsVariant(id: string, variantId: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).postProductsProductVariantsVariant(id, variantId, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductTagApi - axios parameter creator
 * @export
 */
export const ProductTagApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a list of Product Tags.
         * @summary List Product Tags
         * @param {string} [limit] The number of tags to return.
         * @param {string} [offset] The offset of tags to return.
         * @param {string} [value] The value of tags to return.
         * @param {string} [id] The id of tags to return.
         * @param {object} [createdAt] Date comparison for when resulting tas was created, i.e. less than, greater than etc.
         * @param {object} [updatedAt] Date comparison for when resulting tas was updated, i.e. less than, greater than etc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductTags: async (limit?: string, offset?: string, value?: string, id?: string, createdAt?: object, updatedAt?: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product-tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of Product Types.
         * @summary List Product Types
         * @param {string} [limit] The number of types to return.
         * @param {string} [offset] The offset of types to return.
         * @param {string} [value] The value of types to return.
         * @param {string} [id] The id of types to return.
         * @param {object} [createdAt] Date comparison for when resulting tas was created, i.e. less than, greater than etc.
         * @param {object} [updatedAt] Date comparison for when resulting tas was updated, i.e. less than, greater than etc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductTypes: async (limit?: string, offset?: string, value?: string, id?: string, createdAt?: object, updatedAt?: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductTagApi - functional programming interface
 * @export
 */
export const ProductTagApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductTagApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a list of Product Tags.
         * @summary List Product Tags
         * @param {string} [limit] The number of tags to return.
         * @param {string} [offset] The offset of tags to return.
         * @param {string} [value] The value of tags to return.
         * @param {string} [id] The id of tags to return.
         * @param {object} [createdAt] Date comparison for when resulting tas was created, i.e. less than, greater than etc.
         * @param {object} [updatedAt] Date comparison for when resulting tas was updated, i.e. less than, greater than etc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductTags(limit?: string, offset?: string, value?: string, id?: string, createdAt?: object, updatedAt?: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductTags(limit, offset, value, id, createdAt, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a list of Product Types.
         * @summary List Product Types
         * @param {string} [limit] The number of types to return.
         * @param {string} [offset] The offset of types to return.
         * @param {string} [value] The value of types to return.
         * @param {string} [id] The id of types to return.
         * @param {object} [createdAt] Date comparison for when resulting tas was created, i.e. less than, greater than etc.
         * @param {object} [updatedAt] Date comparison for when resulting tas was updated, i.e. less than, greater than etc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductTypes(limit?: string, offset?: string, value?: string, id?: string, createdAt?: object, updatedAt?: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductTypes(limit, offset, value, id, createdAt, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductTagApi - factory interface
 * @export
 */
export const ProductTagApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductTagApiFp(configuration)
    return {
        /**
         * Retrieve a list of Product Tags.
         * @summary List Product Tags
         * @param {string} [limit] The number of tags to return.
         * @param {string} [offset] The offset of tags to return.
         * @param {string} [value] The value of tags to return.
         * @param {string} [id] The id of tags to return.
         * @param {object} [createdAt] Date comparison for when resulting tas was created, i.e. less than, greater than etc.
         * @param {object} [updatedAt] Date comparison for when resulting tas was updated, i.e. less than, greater than etc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductTags(limit?: string, offset?: string, value?: string, id?: string, createdAt?: object, updatedAt?: object, options?: any): AxiosPromise<object> {
            return localVarFp.getProductTags(limit, offset, value, id, createdAt, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of Product Types.
         * @summary List Product Types
         * @param {string} [limit] The number of types to return.
         * @param {string} [offset] The offset of types to return.
         * @param {string} [value] The value of types to return.
         * @param {string} [id] The id of types to return.
         * @param {object} [createdAt] Date comparison for when resulting tas was created, i.e. less than, greater than etc.
         * @param {object} [updatedAt] Date comparison for when resulting tas was updated, i.e. less than, greater than etc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductTypes(limit?: string, offset?: string, value?: string, id?: string, createdAt?: object, updatedAt?: object, options?: any): AxiosPromise<object> {
            return localVarFp.getProductTypes(limit, offset, value, id, createdAt, updatedAt, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductTagApi - object-oriented interface
 * @export
 * @class ProductTagApi
 * @extends {BaseAPI}
 */
export class ProductTagApi extends BaseAPI {
    /**
     * Retrieve a list of Product Tags.
     * @summary List Product Tags
     * @param {string} [limit] The number of tags to return.
     * @param {string} [offset] The offset of tags to return.
     * @param {string} [value] The value of tags to return.
     * @param {string} [id] The id of tags to return.
     * @param {object} [createdAt] Date comparison for when resulting tas was created, i.e. less than, greater than etc.
     * @param {object} [updatedAt] Date comparison for when resulting tas was updated, i.e. less than, greater than etc.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductTagApi
     */
    public getProductTags(limit?: string, offset?: string, value?: string, id?: string, createdAt?: object, updatedAt?: object, options?: AxiosRequestConfig) {
        return ProductTagApiFp(this.configuration).getProductTags(limit, offset, value, id, createdAt, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of Product Types.
     * @summary List Product Types
     * @param {string} [limit] The number of types to return.
     * @param {string} [offset] The offset of types to return.
     * @param {string} [value] The value of types to return.
     * @param {string} [id] The id of types to return.
     * @param {object} [createdAt] Date comparison for when resulting tas was created, i.e. less than, greater than etc.
     * @param {object} [updatedAt] Date comparison for when resulting tas was updated, i.e. less than, greater than etc.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductTagApi
     */
    public getProductTypes(limit?: string, offset?: string, value?: string, id?: string, createdAt?: object, updatedAt?: object, options?: AxiosRequestConfig) {
        return ProductTagApiFp(this.configuration).getProductTypes(limit, offset, value, id, createdAt, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductVariantApi - axios parameter creator
 * @export
 */
export const ProductVariantApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of Product Variants
         * @summary List Product Variants.
         * @param {string} [q] Query used for searching variants.
         * @param {string} [offset] How many variants to skip in the result.
         * @param {string} [limit] Limit the number of variants returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariants: async (q?: string, offset?: string, limit?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/variants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductVariantApi - functional programming interface
 * @export
 */
export const ProductVariantApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductVariantApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a list of Product Variants
         * @summary List Product Variants.
         * @param {string} [q] Query used for searching variants.
         * @param {string} [offset] How many variants to skip in the result.
         * @param {string} [limit] Limit the number of variants returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVariants(q?: string, offset?: string, limit?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVariants(q, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductVariantApi - factory interface
 * @export
 */
export const ProductVariantApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductVariantApiFp(configuration)
    return {
        /**
         * Retrieves a list of Product Variants
         * @summary List Product Variants.
         * @param {string} [q] Query used for searching variants.
         * @param {string} [offset] How many variants to skip in the result.
         * @param {string} [limit] Limit the number of variants returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariants(q?: string, offset?: string, limit?: string, options?: any): AxiosPromise<object> {
            return localVarFp.getVariants(q, offset, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductVariantApi - object-oriented interface
 * @export
 * @class ProductVariantApi
 * @extends {BaseAPI}
 */
export class ProductVariantApi extends BaseAPI {
    /**
     * Retrieves a list of Product Variants
     * @summary List Product Variants.
     * @param {string} [q] Query used for searching variants.
     * @param {string} [offset] How many variants to skip in the result.
     * @param {string} [limit] Limit the number of variants returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductVariantApi
     */
    public getVariants(q?: string, offset?: string, limit?: string, options?: AxiosRequestConfig) {
        return ProductVariantApiFp(this.configuration).getVariants(q, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RegionApi - axios parameter creator
 * @export
 */
export const RegionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a Region.
         * @summary Delete a Region
         * @param {string} id The id of the Region.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegionsRegion: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRegionsRegion', 'id', id)
            const localVarPath = `/regions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a metadata key.
         * @summary Delete Metadata
         * @param {string} id The id of the Region.
         * @param {string} key The metadata key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegionsRegionMetadataKey: async (id: string, key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRegionsRegionMetadataKey', 'id', id)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('deleteRegionsRegionMetadataKey', 'key', key)
            const localVarPath = `/regions/{id}/metadata/{key}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of Regions.
         * @summary List Regions
         * @param {number} [limit] limit the number of regions in response
         * @param {number} [offset] Offset of regions in response (used for pagination)
         * @param {object} [createdAt] Date comparison for when resulting region was created, i.e. less than, greater than etc.
         * @param {object} [updatedAt] Date comparison for when resulting region was updated, i.e. less than, greater than etc.
         * @param {object} [deletedAt] Date comparison for when resulting region was deleted, i.e. less than, greater than etc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegions: async (limit?: number, offset?: number, createdAt?: object, updatedAt?: object, deletedAt?: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/regions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }

            if (deletedAt !== undefined) {
                localVarQueryParameter['deleted_at'] = deletedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Region.
         * @summary Retrieve a Region
         * @param {string} id The id of the Region.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegionsRegion: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRegionsRegion', 'id', id)
            const localVarPath = `/regions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gathers all the fulfillment options available to in the Region.
         * @summary List Fulfillment Options available in the Region
         * @param {string} id The id of the Region.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegionsRegionFulfillmentOptions: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRegionsRegionFulfillmentOptions', 'id', id)
            const localVarPath = `/regions/{id}/fulfillment-options`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Region
         * @summary Create a Region
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRegions: async (uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/regions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Region
         * @summary Update a Region
         * @param {string} id The id of the Region.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRegionsRegion: async (id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postRegionsRegion', 'id', id)
            const localVarPath = `/regions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a Country to the list of Countries in a Region
         * @summary Add Country
         * @param {string} id The id of the Region.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRegionsRegionCountries: async (id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postRegionsRegionCountries', 'id', id)
            const localVarPath = `/regions/{id}/countries`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a Country from the list of Countries in a Region
         * @summary Remove Country
         * @param {string} id The id of the Region.
         * @param {string} countryCode The 2 character ISO code for the Country.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRegionsRegionCountriesCountry: async (id: string, countryCode: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postRegionsRegionCountriesCountry', 'id', id)
            // verify required parameter 'countryCode' is not null or undefined
            assertParamExists('postRegionsRegionCountriesCountry', 'countryCode', countryCode)
            const localVarPath = `/regions/{id}/countries/{country_code}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"country_code"}}`, encodeURIComponent(String(countryCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a Fulfillment Provider to a Region
         * @summary Add Fulfillment Provider
         * @param {string} id The id of the Region.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRegionsRegionFulfillmentProviders: async (id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postRegionsRegionFulfillmentProviders', 'id', id)
            const localVarPath = `/regions/{id}/fulfillment-providers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a Fulfillment Provider.
         * @summary Remove Fulfillment Provider
         * @param {string} id The id of the Region.
         * @param {string} providerId The id of the Fulfillment Provider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRegionsRegionFulfillmentProvidersProvider: async (id: string, providerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postRegionsRegionFulfillmentProvidersProvider', 'id', id)
            // verify required parameter 'providerId' is not null or undefined
            assertParamExists('postRegionsRegionFulfillmentProvidersProvider', 'providerId', providerId)
            const localVarPath = `/regions/{id}/fulfillment-providers/{provider_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"provider_id"}}`, encodeURIComponent(String(providerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the metadata of a Region
         * @summary Set the metadata of a Region
         * @param {string} id The id of the Region.
         * @param {InlineObject6} [inlineObject6] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRegionsRegionMetadata: async (id: string, inlineObject6?: InlineObject6, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postRegionsRegionMetadata', 'id', id)
            const localVarPath = `/regions/{id}/metadata`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject6, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a Payment Provider to a Region
         * @summary Add Payment Provider
         * @param {string} id The id of the Region.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRegionsRegionPaymentProviders: async (id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postRegionsRegionPaymentProviders', 'id', id)
            const localVarPath = `/regions/{id}/payment-providers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a Payment Provider.
         * @summary Remove Payment Provider
         * @param {string} id The id of the Region.
         * @param {string} providerId The id of the Payment Provider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRegionsRegionPaymentProvidersProvider: async (id: string, providerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postRegionsRegionPaymentProvidersProvider', 'id', id)
            // verify required parameter 'providerId' is not null or undefined
            assertParamExists('postRegionsRegionPaymentProvidersProvider', 'providerId', providerId)
            const localVarPath = `/regions/{id}/payment-providers/{provider_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"provider_id"}}`, encodeURIComponent(String(providerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegionApi - functional programming interface
 * @export
 */
export const RegionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RegionApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a Region.
         * @summary Delete a Region
         * @param {string} id The id of the Region.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRegionsRegion(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRegionsRegion(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a metadata key.
         * @summary Delete Metadata
         * @param {string} id The id of the Region.
         * @param {string} key The metadata key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRegionsRegionMetadataKey(id: string, key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRegionsRegionMetadataKey(id, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of Regions.
         * @summary List Regions
         * @param {number} [limit] limit the number of regions in response
         * @param {number} [offset] Offset of regions in response (used for pagination)
         * @param {object} [createdAt] Date comparison for when resulting region was created, i.e. less than, greater than etc.
         * @param {object} [updatedAt] Date comparison for when resulting region was updated, i.e. less than, greater than etc.
         * @param {object} [deletedAt] Date comparison for when resulting region was deleted, i.e. less than, greater than etc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRegions(limit?: number, offset?: number, createdAt?: object, updatedAt?: object, deletedAt?: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRegions(limit, offset, createdAt, updatedAt, deletedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a Region.
         * @summary Retrieve a Region
         * @param {string} id The id of the Region.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRegionsRegion(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRegionsRegion(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gathers all the fulfillment options available to in the Region.
         * @summary List Fulfillment Options available in the Region
         * @param {string} id The id of the Region.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRegionsRegionFulfillmentOptions(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRegionsRegionFulfillmentOptions(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Region
         * @summary Create a Region
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRegions(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRegions(uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a Region
         * @summary Update a Region
         * @param {string} id The id of the Region.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRegionsRegion(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRegionsRegion(id, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a Country to the list of Countries in a Region
         * @summary Add Country
         * @param {string} id The id of the Region.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRegionsRegionCountries(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRegionsRegionCountries(id, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes a Country from the list of Countries in a Region
         * @summary Remove Country
         * @param {string} id The id of the Region.
         * @param {string} countryCode The 2 character ISO code for the Country.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRegionsRegionCountriesCountry(id: string, countryCode: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRegionsRegionCountriesCountry(id, countryCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a Fulfillment Provider to a Region
         * @summary Add Fulfillment Provider
         * @param {string} id The id of the Region.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRegionsRegionFulfillmentProviders(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRegionsRegionFulfillmentProviders(id, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes a Fulfillment Provider.
         * @summary Remove Fulfillment Provider
         * @param {string} id The id of the Region.
         * @param {string} providerId The id of the Fulfillment Provider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRegionsRegionFulfillmentProvidersProvider(id: string, providerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRegionsRegionFulfillmentProvidersProvider(id, providerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets the metadata of a Region
         * @summary Set the metadata of a Region
         * @param {string} id The id of the Region.
         * @param {InlineObject6} [inlineObject6] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRegionsRegionMetadata(id: string, inlineObject6?: InlineObject6, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRegionsRegionMetadata(id, inlineObject6, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a Payment Provider to a Region
         * @summary Add Payment Provider
         * @param {string} id The id of the Region.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRegionsRegionPaymentProviders(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRegionsRegionPaymentProviders(id, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes a Payment Provider.
         * @summary Remove Payment Provider
         * @param {string} id The id of the Region.
         * @param {string} providerId The id of the Payment Provider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRegionsRegionPaymentProvidersProvider(id: string, providerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRegionsRegionPaymentProvidersProvider(id, providerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RegionApi - factory interface
 * @export
 */
export const RegionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RegionApiFp(configuration)
    return {
        /**
         * Deletes a Region.
         * @summary Delete a Region
         * @param {string} id The id of the Region.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegionsRegion(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteRegionsRegion(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a metadata key.
         * @summary Delete Metadata
         * @param {string} id The id of the Region.
         * @param {string} key The metadata key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegionsRegionMetadataKey(id: string, key: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteRegionsRegionMetadataKey(id, key, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of Regions.
         * @summary List Regions
         * @param {number} [limit] limit the number of regions in response
         * @param {number} [offset] Offset of regions in response (used for pagination)
         * @param {object} [createdAt] Date comparison for when resulting region was created, i.e. less than, greater than etc.
         * @param {object} [updatedAt] Date comparison for when resulting region was updated, i.e. less than, greater than etc.
         * @param {object} [deletedAt] Date comparison for when resulting region was deleted, i.e. less than, greater than etc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegions(limit?: number, offset?: number, createdAt?: object, updatedAt?: object, deletedAt?: object, options?: any): AxiosPromise<object> {
            return localVarFp.getRegions(limit, offset, createdAt, updatedAt, deletedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Region.
         * @summary Retrieve a Region
         * @param {string} id The id of the Region.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegionsRegion(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.getRegionsRegion(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Gathers all the fulfillment options available to in the Region.
         * @summary List Fulfillment Options available in the Region
         * @param {string} id The id of the Region.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegionsRegionFulfillmentOptions(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.getRegionsRegionFulfillmentOptions(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Region
         * @summary Create a Region
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRegions(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postRegions(uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a Region
         * @summary Update a Region
         * @param {string} id The id of the Region.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRegionsRegion(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postRegionsRegion(id, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a Country to the list of Countries in a Region
         * @summary Add Country
         * @param {string} id The id of the Region.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRegionsRegionCountries(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postRegionsRegionCountries(id, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a Country from the list of Countries in a Region
         * @summary Remove Country
         * @param {string} id The id of the Region.
         * @param {string} countryCode The 2 character ISO code for the Country.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRegionsRegionCountriesCountry(id: string, countryCode: string, options?: any): AxiosPromise<object> {
            return localVarFp.postRegionsRegionCountriesCountry(id, countryCode, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a Fulfillment Provider to a Region
         * @summary Add Fulfillment Provider
         * @param {string} id The id of the Region.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRegionsRegionFulfillmentProviders(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postRegionsRegionFulfillmentProviders(id, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a Fulfillment Provider.
         * @summary Remove Fulfillment Provider
         * @param {string} id The id of the Region.
         * @param {string} providerId The id of the Fulfillment Provider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRegionsRegionFulfillmentProvidersProvider(id: string, providerId: string, options?: any): AxiosPromise<object> {
            return localVarFp.postRegionsRegionFulfillmentProvidersProvider(id, providerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the metadata of a Region
         * @summary Set the metadata of a Region
         * @param {string} id The id of the Region.
         * @param {InlineObject6} [inlineObject6] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRegionsRegionMetadata(id: string, inlineObject6?: InlineObject6, options?: any): AxiosPromise<object> {
            return localVarFp.postRegionsRegionMetadata(id, inlineObject6, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a Payment Provider to a Region
         * @summary Add Payment Provider
         * @param {string} id The id of the Region.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRegionsRegionPaymentProviders(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postRegionsRegionPaymentProviders(id, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a Payment Provider.
         * @summary Remove Payment Provider
         * @param {string} id The id of the Region.
         * @param {string} providerId The id of the Payment Provider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRegionsRegionPaymentProvidersProvider(id: string, providerId: string, options?: any): AxiosPromise<object> {
            return localVarFp.postRegionsRegionPaymentProvidersProvider(id, providerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RegionApi - object-oriented interface
 * @export
 * @class RegionApi
 * @extends {BaseAPI}
 */
export class RegionApi extends BaseAPI {
    /**
     * Deletes a Region.
     * @summary Delete a Region
     * @param {string} id The id of the Region.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionApi
     */
    public deleteRegionsRegion(id: string, options?: AxiosRequestConfig) {
        return RegionApiFp(this.configuration).deleteRegionsRegion(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a metadata key.
     * @summary Delete Metadata
     * @param {string} id The id of the Region.
     * @param {string} key The metadata key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionApi
     */
    public deleteRegionsRegionMetadataKey(id: string, key: string, options?: AxiosRequestConfig) {
        return RegionApiFp(this.configuration).deleteRegionsRegionMetadataKey(id, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of Regions.
     * @summary List Regions
     * @param {number} [limit] limit the number of regions in response
     * @param {number} [offset] Offset of regions in response (used for pagination)
     * @param {object} [createdAt] Date comparison for when resulting region was created, i.e. less than, greater than etc.
     * @param {object} [updatedAt] Date comparison for when resulting region was updated, i.e. less than, greater than etc.
     * @param {object} [deletedAt] Date comparison for when resulting region was deleted, i.e. less than, greater than etc.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionApi
     */
    public getRegions(limit?: number, offset?: number, createdAt?: object, updatedAt?: object, deletedAt?: object, options?: AxiosRequestConfig) {
        return RegionApiFp(this.configuration).getRegions(limit, offset, createdAt, updatedAt, deletedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Region.
     * @summary Retrieve a Region
     * @param {string} id The id of the Region.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionApi
     */
    public getRegionsRegion(id: string, options?: AxiosRequestConfig) {
        return RegionApiFp(this.configuration).getRegionsRegion(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gathers all the fulfillment options available to in the Region.
     * @summary List Fulfillment Options available in the Region
     * @param {string} id The id of the Region.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionApi
     */
    public getRegionsRegionFulfillmentOptions(id: string, options?: AxiosRequestConfig) {
        return RegionApiFp(this.configuration).getRegionsRegionFulfillmentOptions(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Region
     * @summary Create a Region
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionApi
     */
    public postRegions(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return RegionApiFp(this.configuration).postRegions(uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a Region
     * @summary Update a Region
     * @param {string} id The id of the Region.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionApi
     */
    public postRegionsRegion(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return RegionApiFp(this.configuration).postRegionsRegion(id, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a Country to the list of Countries in a Region
     * @summary Add Country
     * @param {string} id The id of the Region.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionApi
     */
    public postRegionsRegionCountries(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return RegionApiFp(this.configuration).postRegionsRegionCountries(id, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a Country from the list of Countries in a Region
     * @summary Remove Country
     * @param {string} id The id of the Region.
     * @param {string} countryCode The 2 character ISO code for the Country.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionApi
     */
    public postRegionsRegionCountriesCountry(id: string, countryCode: string, options?: AxiosRequestConfig) {
        return RegionApiFp(this.configuration).postRegionsRegionCountriesCountry(id, countryCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a Fulfillment Provider to a Region
     * @summary Add Fulfillment Provider
     * @param {string} id The id of the Region.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionApi
     */
    public postRegionsRegionFulfillmentProviders(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return RegionApiFp(this.configuration).postRegionsRegionFulfillmentProviders(id, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a Fulfillment Provider.
     * @summary Remove Fulfillment Provider
     * @param {string} id The id of the Region.
     * @param {string} providerId The id of the Fulfillment Provider.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionApi
     */
    public postRegionsRegionFulfillmentProvidersProvider(id: string, providerId: string, options?: AxiosRequestConfig) {
        return RegionApiFp(this.configuration).postRegionsRegionFulfillmentProvidersProvider(id, providerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets the metadata of a Region
     * @summary Set the metadata of a Region
     * @param {string} id The id of the Region.
     * @param {InlineObject6} [inlineObject6] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionApi
     */
    public postRegionsRegionMetadata(id: string, inlineObject6?: InlineObject6, options?: AxiosRequestConfig) {
        return RegionApiFp(this.configuration).postRegionsRegionMetadata(id, inlineObject6, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a Payment Provider to a Region
     * @summary Add Payment Provider
     * @param {string} id The id of the Region.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionApi
     */
    public postRegionsRegionPaymentProviders(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return RegionApiFp(this.configuration).postRegionsRegionPaymentProviders(id, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a Payment Provider.
     * @summary Remove Payment Provider
     * @param {string} id The id of the Region.
     * @param {string} providerId The id of the Payment Provider.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionApi
     */
    public postRegionsRegionPaymentProvidersProvider(id: string, providerId: string, options?: AxiosRequestConfig) {
        return RegionApiFp(this.configuration).postRegionsRegionPaymentProvidersProvider(id, providerId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReturnApi - axios parameter creator
 * @export
 */
export const ReturnApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of Returns
         * @summary List Returns
         * @param {number} limit The upper limit for the amount of responses returned.
         * @param {number} offset The offset of the list returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReturns: async (limit: number, offset: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('getReturns', 'limit', limit)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('getReturns', 'offset', offset)
            const localVarPath = `/returns`
                .replace(`{${"limit"}}`, encodeURIComponent(String(limit)))
                .replace(`{${"offset"}}`, encodeURIComponent(String(offset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers a Return as canceled.
         * @summary Cancel a Return
         * @param {string} id The id of the Return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postReturnsReturnCancel: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postReturnsReturnCancel', 'id', id)
            const localVarPath = `/returns/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers a Return as received. Updates statuses on Orders and Swaps accordingly.
         * @summary Receive a Return
         * @param {string} id The id of the Return.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postReturnsReturnReceive: async (id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postReturnsReturnReceive', 'id', id)
            const localVarPath = `/returns/{id}/receive`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReturnApi - functional programming interface
 * @export
 */
export const ReturnApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReturnApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a list of Returns
         * @summary List Returns
         * @param {number} limit The upper limit for the amount of responses returned.
         * @param {number} offset The offset of the list returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReturns(limit: number, offset: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReturns(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Registers a Return as canceled.
         * @summary Cancel a Return
         * @param {string} id The id of the Return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postReturnsReturnCancel(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postReturnsReturnCancel(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Registers a Return as received. Updates statuses on Orders and Swaps accordingly.
         * @summary Receive a Return
         * @param {string} id The id of the Return.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postReturnsReturnReceive(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postReturnsReturnReceive(id, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReturnApi - factory interface
 * @export
 */
export const ReturnApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReturnApiFp(configuration)
    return {
        /**
         * Retrieves a list of Returns
         * @summary List Returns
         * @param {number} limit The upper limit for the amount of responses returned.
         * @param {number} offset The offset of the list returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReturns(limit: number, offset: number, options?: any): AxiosPromise<object> {
            return localVarFp.getReturns(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Registers a Return as canceled.
         * @summary Cancel a Return
         * @param {string} id The id of the Return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postReturnsReturnCancel(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.postReturnsReturnCancel(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Registers a Return as received. Updates statuses on Orders and Swaps accordingly.
         * @summary Receive a Return
         * @param {string} id The id of the Return.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postReturnsReturnReceive(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postReturnsReturnReceive(id, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReturnApi - object-oriented interface
 * @export
 * @class ReturnApi
 * @extends {BaseAPI}
 */
export class ReturnApi extends BaseAPI {
    /**
     * Retrieves a list of Returns
     * @summary List Returns
     * @param {number} limit The upper limit for the amount of responses returned.
     * @param {number} offset The offset of the list returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReturnApi
     */
    public getReturns(limit: number, offset: number, options?: AxiosRequestConfig) {
        return ReturnApiFp(this.configuration).getReturns(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registers a Return as canceled.
     * @summary Cancel a Return
     * @param {string} id The id of the Return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReturnApi
     */
    public postReturnsReturnCancel(id: string, options?: AxiosRequestConfig) {
        return ReturnApiFp(this.configuration).postReturnsReturnCancel(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registers a Return as received. Updates statuses on Orders and Swaps accordingly.
     * @summary Receive a Return
     * @param {string} id The id of the Return.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReturnApi
     */
    public postReturnsReturnReceive(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return ReturnApiFp(this.configuration).postReturnsReturnReceive(id, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReturnReasonApi - axios parameter creator
 * @export
 */
export const ReturnReasonApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a return reason.
         * @summary Delete a return reason
         * @param {string} id The id of the return reason
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReturnReason: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteReturnReason', 'id', id)
            const localVarPath = `/return-reasons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of Return Reasons.
         * @summary List Return Reasons
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReturnReasons: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/return-reasons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Return Reason.
         * @summary Retrieve a Return Reason
         * @param {string} id The id of the Return Reason.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReturnReasonsReason: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getReturnReasonsReason', 'id', id)
            const localVarPath = `/return-reasons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Return Reason
         * @summary Create a Return Reason
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postReturnReasons: async (uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/return-reasons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Return Reason
         * @summary Update a Return Reason
         * @param {string} id The id of the Return Reason.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postReturnReasonsReason: async (id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postReturnReasonsReason', 'id', id)
            const localVarPath = `/return-reasons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReturnReasonApi - functional programming interface
 * @export
 */
export const ReturnReasonApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReturnReasonApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a return reason.
         * @summary Delete a return reason
         * @param {string} id The id of the return reason
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteReturnReason(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReturnReason(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of Return Reasons.
         * @summary List Return Reasons
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReturnReasons(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReturnReasons(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a Return Reason.
         * @summary Retrieve a Return Reason
         * @param {string} id The id of the Return Reason.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReturnReasonsReason(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReturnReasonsReason(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Return Reason
         * @summary Create a Return Reason
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postReturnReasons(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postReturnReasons(uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a Return Reason
         * @summary Update a Return Reason
         * @param {string} id The id of the Return Reason.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postReturnReasonsReason(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postReturnReasonsReason(id, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReturnReasonApi - factory interface
 * @export
 */
export const ReturnReasonApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReturnReasonApiFp(configuration)
    return {
        /**
         * Deletes a return reason.
         * @summary Delete a return reason
         * @param {string} id The id of the return reason
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReturnReason(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteReturnReason(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of Return Reasons.
         * @summary List Return Reasons
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReturnReasons(options?: any): AxiosPromise<object> {
            return localVarFp.getReturnReasons(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Return Reason.
         * @summary Retrieve a Return Reason
         * @param {string} id The id of the Return Reason.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReturnReasonsReason(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.getReturnReasonsReason(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Return Reason
         * @summary Create a Return Reason
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postReturnReasons(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postReturnReasons(uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a Return Reason
         * @summary Update a Return Reason
         * @param {string} id The id of the Return Reason.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postReturnReasonsReason(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postReturnReasonsReason(id, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReturnReasonApi - object-oriented interface
 * @export
 * @class ReturnReasonApi
 * @extends {BaseAPI}
 */
export class ReturnReasonApi extends BaseAPI {
    /**
     * Deletes a return reason.
     * @summary Delete a return reason
     * @param {string} id The id of the return reason
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReturnReasonApi
     */
    public deleteReturnReason(id: string, options?: AxiosRequestConfig) {
        return ReturnReasonApiFp(this.configuration).deleteReturnReason(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of Return Reasons.
     * @summary List Return Reasons
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReturnReasonApi
     */
    public getReturnReasons(options?: AxiosRequestConfig) {
        return ReturnReasonApiFp(this.configuration).getReturnReasons(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Return Reason.
     * @summary Retrieve a Return Reason
     * @param {string} id The id of the Return Reason.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReturnReasonApi
     */
    public getReturnReasonsReason(id: string, options?: AxiosRequestConfig) {
        return ReturnReasonApiFp(this.configuration).getReturnReasonsReason(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Return Reason
     * @summary Create a Return Reason
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReturnReasonApi
     */
    public postReturnReasons(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return ReturnReasonApiFp(this.configuration).postReturnReasons(uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a Return Reason
     * @summary Update a Return Reason
     * @param {string} id The id of the Return Reason.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReturnReasonApi
     */
    public postReturnReasonsReason(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return ReturnReasonApiFp(this.configuration).postReturnReasonsReason(id, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ShippingOptionApi - axios parameter creator
 * @export
 */
export const ShippingOptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a Shipping Option.
         * @summary Delete a Shipping Option
         * @param {string} id The id of the Shipping Option.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShippingOptionsOption: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteShippingOptionsOption', 'id', id)
            const localVarPath = `/shipping-options/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of Shipping Options.
         * @summary List Shipping Options
         * @param {string} [regionId] Region to fetch options from
         * @param {boolean} [isReturn] Flag for fetching return options
         * @param {boolean} [adminOnly] Flag for fetching admin specific options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShippingOptions: async (regionId?: string, isReturn?: boolean, adminOnly?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/shipping-options`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (isReturn !== undefined) {
                localVarQueryParameter['is_return'] = isReturn;
            }

            if (adminOnly !== undefined) {
                localVarQueryParameter['admin_only'] = adminOnly;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Shipping Option.
         * @summary Retrieve a Shipping Option
         * @param {string} id The id of the Shipping Option.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShippingOptionsOption: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getShippingOptionsOption', 'id', id)
            const localVarPath = `/shipping-options/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Shipping Option
         * @summary Create Shipping Option
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postShippingOptions: async (uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/shipping-options`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Shipping Option
         * @summary Update Shipping Option
         * @param {string} id The id of the Shipping Option.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postShippingOptionsOption: async (id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postShippingOptionsOption', 'id', id)
            const localVarPath = `/shipping-options/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShippingOptionApi - functional programming interface
 * @export
 */
export const ShippingOptionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShippingOptionApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a Shipping Option.
         * @summary Delete a Shipping Option
         * @param {string} id The id of the Shipping Option.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteShippingOptionsOption(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteShippingOptionsOption(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of Shipping Options.
         * @summary List Shipping Options
         * @param {string} [regionId] Region to fetch options from
         * @param {boolean} [isReturn] Flag for fetching return options
         * @param {boolean} [adminOnly] Flag for fetching admin specific options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShippingOptions(regionId?: string, isReturn?: boolean, adminOnly?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getShippingOptions(regionId, isReturn, adminOnly, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a Shipping Option.
         * @summary Retrieve a Shipping Option
         * @param {string} id The id of the Shipping Option.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShippingOptionsOption(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getShippingOptionsOption(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Shipping Option
         * @summary Create Shipping Option
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postShippingOptions(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postShippingOptions(uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a Shipping Option
         * @summary Update Shipping Option
         * @param {string} id The id of the Shipping Option.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postShippingOptionsOption(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postShippingOptionsOption(id, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ShippingOptionApi - factory interface
 * @export
 */
export const ShippingOptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShippingOptionApiFp(configuration)
    return {
        /**
         * Deletes a Shipping Option.
         * @summary Delete a Shipping Option
         * @param {string} id The id of the Shipping Option.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShippingOptionsOption(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteShippingOptionsOption(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of Shipping Options.
         * @summary List Shipping Options
         * @param {string} [regionId] Region to fetch options from
         * @param {boolean} [isReturn] Flag for fetching return options
         * @param {boolean} [adminOnly] Flag for fetching admin specific options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShippingOptions(regionId?: string, isReturn?: boolean, adminOnly?: boolean, options?: any): AxiosPromise<object> {
            return localVarFp.getShippingOptions(regionId, isReturn, adminOnly, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Shipping Option.
         * @summary Retrieve a Shipping Option
         * @param {string} id The id of the Shipping Option.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShippingOptionsOption(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.getShippingOptionsOption(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Shipping Option
         * @summary Create Shipping Option
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postShippingOptions(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postShippingOptions(uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a Shipping Option
         * @summary Update Shipping Option
         * @param {string} id The id of the Shipping Option.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postShippingOptionsOption(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postShippingOptionsOption(id, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShippingOptionApi - object-oriented interface
 * @export
 * @class ShippingOptionApi
 * @extends {BaseAPI}
 */
export class ShippingOptionApi extends BaseAPI {
    /**
     * Deletes a Shipping Option.
     * @summary Delete a Shipping Option
     * @param {string} id The id of the Shipping Option.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingOptionApi
     */
    public deleteShippingOptionsOption(id: string, options?: AxiosRequestConfig) {
        return ShippingOptionApiFp(this.configuration).deleteShippingOptionsOption(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of Shipping Options.
     * @summary List Shipping Options
     * @param {string} [regionId] Region to fetch options from
     * @param {boolean} [isReturn] Flag for fetching return options
     * @param {boolean} [adminOnly] Flag for fetching admin specific options
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingOptionApi
     */
    public getShippingOptions(regionId?: string, isReturn?: boolean, adminOnly?: boolean, options?: AxiosRequestConfig) {
        return ShippingOptionApiFp(this.configuration).getShippingOptions(regionId, isReturn, adminOnly, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Shipping Option.
     * @summary Retrieve a Shipping Option
     * @param {string} id The id of the Shipping Option.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingOptionApi
     */
    public getShippingOptionsOption(id: string, options?: AxiosRequestConfig) {
        return ShippingOptionApiFp(this.configuration).getShippingOptionsOption(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Shipping Option
     * @summary Create Shipping Option
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingOptionApi
     */
    public postShippingOptions(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return ShippingOptionApiFp(this.configuration).postShippingOptions(uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a Shipping Option
     * @summary Update Shipping Option
     * @param {string} id The id of the Shipping Option.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingOptionApi
     */
    public postShippingOptionsOption(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return ShippingOptionApiFp(this.configuration).postShippingOptionsOption(id, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ShippingProfileApi - axios parameter creator
 * @export
 */
export const ShippingProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a Shipping Profile.
         * @summary Delete a Shipping Profile
         * @param {string} id The id of the Shipping Profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShippingProfilesProfile: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteShippingProfilesProfile', 'id', id)
            const localVarPath = `/shipping-profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of Shipping Profile.
         * @summary List Shipping Profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShippingProfiles: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/shipping-profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Shipping Profile.
         * @summary Retrieve a Shipping Profile
         * @param {string} id The id of the Shipping Profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShippingProfilesProfile: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getShippingProfilesProfile', 'id', id)
            const localVarPath = `/shipping-profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Shipping Profile
         * @summary Create a Shipping Profile
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postShippingProfiles: async (uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/shipping-profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Shipping Profile
         * @summary Update a Shipping Profiles
         * @param {string} id The id of the Shipping Profile.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postShippingProfilesProfile: async (id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postShippingProfilesProfile', 'id', id)
            const localVarPath = `/shipping-profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShippingProfileApi - functional programming interface
 * @export
 */
export const ShippingProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShippingProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a Shipping Profile.
         * @summary Delete a Shipping Profile
         * @param {string} id The id of the Shipping Profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteShippingProfilesProfile(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteShippingProfilesProfile(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of Shipping Profile.
         * @summary List Shipping Profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShippingProfiles(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getShippingProfiles(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a Shipping Profile.
         * @summary Retrieve a Shipping Profile
         * @param {string} id The id of the Shipping Profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShippingProfilesProfile(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getShippingProfilesProfile(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Shipping Profile
         * @summary Create a Shipping Profile
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postShippingProfiles(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postShippingProfiles(uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a Shipping Profile
         * @summary Update a Shipping Profiles
         * @param {string} id The id of the Shipping Profile.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postShippingProfilesProfile(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postShippingProfilesProfile(id, uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ShippingProfileApi - factory interface
 * @export
 */
export const ShippingProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShippingProfileApiFp(configuration)
    return {
        /**
         * Deletes a Shipping Profile.
         * @summary Delete a Shipping Profile
         * @param {string} id The id of the Shipping Profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShippingProfilesProfile(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteShippingProfilesProfile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of Shipping Profile.
         * @summary List Shipping Profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShippingProfiles(options?: any): AxiosPromise<object> {
            return localVarFp.getShippingProfiles(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Shipping Profile.
         * @summary Retrieve a Shipping Profile
         * @param {string} id The id of the Shipping Profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShippingProfilesProfile(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.getShippingProfilesProfile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Shipping Profile
         * @summary Create a Shipping Profile
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postShippingProfiles(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postShippingProfiles(uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a Shipping Profile
         * @summary Update a Shipping Profiles
         * @param {string} id The id of the Shipping Profile.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postShippingProfilesProfile(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postShippingProfilesProfile(id, uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShippingProfileApi - object-oriented interface
 * @export
 * @class ShippingProfileApi
 * @extends {BaseAPI}
 */
export class ShippingProfileApi extends BaseAPI {
    /**
     * Deletes a Shipping Profile.
     * @summary Delete a Shipping Profile
     * @param {string} id The id of the Shipping Profile.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingProfileApi
     */
    public deleteShippingProfilesProfile(id: string, options?: AxiosRequestConfig) {
        return ShippingProfileApiFp(this.configuration).deleteShippingProfilesProfile(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of Shipping Profile.
     * @summary List Shipping Profiles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingProfileApi
     */
    public getShippingProfiles(options?: AxiosRequestConfig) {
        return ShippingProfileApiFp(this.configuration).getShippingProfiles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Shipping Profile.
     * @summary Retrieve a Shipping Profile
     * @param {string} id The id of the Shipping Profile.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingProfileApi
     */
    public getShippingProfilesProfile(id: string, options?: AxiosRequestConfig) {
        return ShippingProfileApiFp(this.configuration).getShippingProfilesProfile(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Shipping Profile
     * @summary Create a Shipping Profile
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingProfileApi
     */
    public postShippingProfiles(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return ShippingProfileApiFp(this.configuration).postShippingProfiles(uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a Shipping Profile
     * @summary Update a Shipping Profiles
     * @param {string} id The id of the Shipping Profile.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingProfileApi
     */
    public postShippingProfilesProfile(id: string, uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return ShippingProfileApiFp(this.configuration).postShippingProfilesProfile(id, uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StoreApi - axios parameter creator
 * @export
 */
export const StoreApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Removes a Currency Code from the available currencies.
         * @summary Remove a Currency Code
         * @param {string} code The 3 character ISO currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStoreCurrenciesCode: async (code: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('deleteStoreCurrenciesCode', 'code', code)
            const localVarPath = `/store/currencies/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the Store details
         * @summary Retrieve Store details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStore: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/store`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the configured Payment Providers
         * @summary Retrieve configured Payment Providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorePaymentProviders: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/store/payment-providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the configured Tax Providers
         * @summary Retrieve configured Tax Providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoreTaxProviders: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/store/tax-providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the Store details
         * @summary Update Store details.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStore: async (uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/store`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a Currency Code to the available currencies.
         * @summary Add a Currency Code
         * @param {string} code The 3 character ISO currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStoreCurrenciesCode: async (code: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('postStoreCurrenciesCode', 'code', code)
            const localVarPath = `/store/currencies/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoreApi - functional programming interface
 * @export
 */
export const StoreApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StoreApiAxiosParamCreator(configuration)
    return {
        /**
         * Removes a Currency Code from the available currencies.
         * @summary Remove a Currency Code
         * @param {string} code The 3 character ISO currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStoreCurrenciesCode(code: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStoreCurrenciesCode(code, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the Store details
         * @summary Retrieve Store details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStore(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStore(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the configured Payment Providers
         * @summary Retrieve configured Payment Providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStorePaymentProviders(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStorePaymentProviders(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the configured Tax Providers
         * @summary Retrieve configured Tax Providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStoreTaxProviders(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStoreTaxProviders(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the Store details
         * @summary Update Store details.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postStore(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postStore(uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a Currency Code to the available currencies.
         * @summary Add a Currency Code
         * @param {string} code The 3 character ISO currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postStoreCurrenciesCode(code: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postStoreCurrenciesCode(code, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StoreApi - factory interface
 * @export
 */
export const StoreApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StoreApiFp(configuration)
    return {
        /**
         * Removes a Currency Code from the available currencies.
         * @summary Remove a Currency Code
         * @param {string} code The 3 character ISO currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStoreCurrenciesCode(code: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteStoreCurrenciesCode(code, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the Store details
         * @summary Retrieve Store details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStore(options?: any): AxiosPromise<object> {
            return localVarFp.getStore(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the configured Payment Providers
         * @summary Retrieve configured Payment Providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorePaymentProviders(options?: any): AxiosPromise<object> {
            return localVarFp.getStorePaymentProviders(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the configured Tax Providers
         * @summary Retrieve configured Tax Providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoreTaxProviders(options?: any): AxiosPromise<object> {
            return localVarFp.getStoreTaxProviders(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the Store details
         * @summary Update Store details.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStore(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postStore(uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a Currency Code to the available currencies.
         * @summary Add a Currency Code
         * @param {string} code The 3 character ISO currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStoreCurrenciesCode(code: string, options?: any): AxiosPromise<object> {
            return localVarFp.postStoreCurrenciesCode(code, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StoreApi - object-oriented interface
 * @export
 * @class StoreApi
 * @extends {BaseAPI}
 */
export class StoreApi extends BaseAPI {
    /**
     * Removes a Currency Code from the available currencies.
     * @summary Remove a Currency Code
     * @param {string} code The 3 character ISO currency code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public deleteStoreCurrenciesCode(code: string, options?: AxiosRequestConfig) {
        return StoreApiFp(this.configuration).deleteStoreCurrenciesCode(code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the Store details
     * @summary Retrieve Store details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public getStore(options?: AxiosRequestConfig) {
        return StoreApiFp(this.configuration).getStore(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the configured Payment Providers
     * @summary Retrieve configured Payment Providers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public getStorePaymentProviders(options?: AxiosRequestConfig) {
        return StoreApiFp(this.configuration).getStorePaymentProviders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the configured Tax Providers
     * @summary Retrieve configured Tax Providers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public getStoreTaxProviders(options?: AxiosRequestConfig) {
        return StoreApiFp(this.configuration).getStoreTaxProviders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the Store details
     * @summary Update Store details.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public postStore(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return StoreApiFp(this.configuration).postStore(uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a Currency Code to the available currencies.
     * @summary Add a Currency Code
     * @param {string} code The 3 character ISO currency code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public postStoreCurrenciesCode(code: string, options?: AxiosRequestConfig) {
        return StoreApiFp(this.configuration).postStoreCurrenciesCode(code, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SwapApi - axios parameter creator
 * @export
 */
export const SwapApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of Swaps.
         * @summary List Swaps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwaps: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/swaps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Swap.
         * @summary Retrieve a Swap
         * @param {string} id The id of the Swap.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwapsSwap: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSwapsSwap', 'id', id)
            const localVarPath = `/swaps/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancels a Swap
         * @summary Cancels a Swap
         * @param {string} id The id of the Order.
         * @param {string} swapId The id of the Swap.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersSwapCancel: async (id: string, swapId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postOrdersSwapCancel', 'id', id)
            // verify required parameter 'swapId' is not null or undefined
            assertParamExists('postOrdersSwapCancel', 'swapId', swapId)
            const localVarPath = `/orders/{id}/swaps/{swap_id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"swap_id"}}`, encodeURIComponent(String(swapId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SwapApi - functional programming interface
 * @export
 */
export const SwapApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SwapApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a list of Swaps.
         * @summary List Swaps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSwaps(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSwaps(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a Swap.
         * @summary Retrieve a Swap
         * @param {string} id The id of the Swap.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSwapsSwap(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSwapsSwap(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancels a Swap
         * @summary Cancels a Swap
         * @param {string} id The id of the Order.
         * @param {string} swapId The id of the Swap.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrdersSwapCancel(id: string, swapId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postOrdersSwapCancel(id, swapId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SwapApi - factory interface
 * @export
 */
export const SwapApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SwapApiFp(configuration)
    return {
        /**
         * Retrieves a list of Swaps.
         * @summary List Swaps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwaps(options?: any): AxiosPromise<object> {
            return localVarFp.getSwaps(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Swap.
         * @summary Retrieve a Swap
         * @param {string} id The id of the Swap.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwapsSwap(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.getSwapsSwap(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancels a Swap
         * @summary Cancels a Swap
         * @param {string} id The id of the Order.
         * @param {string} swapId The id of the Swap.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersSwapCancel(id: string, swapId: string, options?: any): AxiosPromise<object> {
            return localVarFp.postOrdersSwapCancel(id, swapId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SwapApi - object-oriented interface
 * @export
 * @class SwapApi
 * @extends {BaseAPI}
 */
export class SwapApi extends BaseAPI {
    /**
     * Retrieves a list of Swaps.
     * @summary List Swaps
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SwapApi
     */
    public getSwaps(options?: AxiosRequestConfig) {
        return SwapApiFp(this.configuration).getSwaps(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Swap.
     * @summary Retrieve a Swap
     * @param {string} id The id of the Swap.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SwapApi
     */
    public getSwapsSwap(id: string, options?: AxiosRequestConfig) {
        return SwapApiFp(this.configuration).getSwapsSwap(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancels a Swap
     * @summary Cancels a Swap
     * @param {string} id The id of the Order.
     * @param {string} swapId The id of the Swap.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SwapApi
     */
    public postOrdersSwapCancel(id: string, swapId: string, options?: AxiosRequestConfig) {
        return SwapApiFp(this.configuration).postOrdersSwapCancel(id, swapId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TaxRatesApi - axios parameter creator
 * @export
 */
export const TaxRatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a Tax Rate
         * @summary Delete a Tax Rate
         * @param {string} id The id of the Shipping Option.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxRatesTaxRate: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTaxRatesTaxRate', 'id', id)
            const localVarPath = `/tax-rates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a Tax Rate from a list of Product Types
         * @summary Remove Tax Rate from Product Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxRatesTaxRateProductTypes: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tax-rates/:id/product-types/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a Tax Rate from a list of Products
         * @summary Removes Tax Rate from Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxRatesTaxRateProducts: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tax-rates/:id/products/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a Tax Rate from a list of Product Types
         * @summary Removes a Tax Rate from Product Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxRatesTaxRateShippingOptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tax-rates/:id/shipping-options/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a TaxRate
         * @summary Get Tax Rate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxRatesTaxRate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tax-rates/:id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Tax Rate
         * @summary Create a Tax Rate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTaxRates: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tax-rates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Tax Rate
         * @summary Update a Tax Rate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTaxRatesTaxRate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tax-rates/:id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Associates a Tax Rate with a list of Product Types
         * @summary Add Tax Rate to Product Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTaxRatesTaxRateProductTypes: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tax-rates/:id/product-types/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Associates a Tax Rate with a list of Products
         * @summary Add Tax Rate to Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTaxRatesTaxRateProducts: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tax-rates/:id/products/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Associates a Tax Rate with a list of Product Types
         * @summary Add Tax Rate to Product Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTaxRatesTaxRateShippingOptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tax-rates/:id/shipping-options/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaxRatesApi - functional programming interface
 * @export
 */
export const TaxRatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaxRatesApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a Tax Rate
         * @summary Delete a Tax Rate
         * @param {string} id The id of the Shipping Option.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTaxRatesTaxRate(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTaxRatesTaxRate(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes a Tax Rate from a list of Product Types
         * @summary Remove Tax Rate from Product Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTaxRatesTaxRateProductTypes(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTaxRatesTaxRateProductTypes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes a Tax Rate from a list of Products
         * @summary Removes Tax Rate from Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTaxRatesTaxRateProducts(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTaxRatesTaxRateProducts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes a Tax Rate from a list of Product Types
         * @summary Removes a Tax Rate from Product Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTaxRatesTaxRateShippingOptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTaxRatesTaxRateShippingOptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a TaxRate
         * @summary Get Tax Rate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaxRatesTaxRate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaxRatesTaxRate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Tax Rate
         * @summary Create a Tax Rate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTaxRates(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTaxRates(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a Tax Rate
         * @summary Update a Tax Rate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTaxRatesTaxRate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTaxRatesTaxRate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Associates a Tax Rate with a list of Product Types
         * @summary Add Tax Rate to Product Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTaxRatesTaxRateProductTypes(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTaxRatesTaxRateProductTypes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Associates a Tax Rate with a list of Products
         * @summary Add Tax Rate to Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTaxRatesTaxRateProducts(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTaxRatesTaxRateProducts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Associates a Tax Rate with a list of Product Types
         * @summary Add Tax Rate to Product Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTaxRatesTaxRateShippingOptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTaxRatesTaxRateShippingOptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TaxRatesApi - factory interface
 * @export
 */
export const TaxRatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaxRatesApiFp(configuration)
    return {
        /**
         * Deletes a Tax Rate
         * @summary Delete a Tax Rate
         * @param {string} id The id of the Shipping Option.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxRatesTaxRate(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteTaxRatesTaxRate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a Tax Rate from a list of Product Types
         * @summary Remove Tax Rate from Product Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxRatesTaxRateProductTypes(options?: any): AxiosPromise<object> {
            return localVarFp.deleteTaxRatesTaxRateProductTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a Tax Rate from a list of Products
         * @summary Removes Tax Rate from Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxRatesTaxRateProducts(options?: any): AxiosPromise<object> {
            return localVarFp.deleteTaxRatesTaxRateProducts(options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a Tax Rate from a list of Product Types
         * @summary Removes a Tax Rate from Product Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxRatesTaxRateShippingOptions(options?: any): AxiosPromise<object> {
            return localVarFp.deleteTaxRatesTaxRateShippingOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a TaxRate
         * @summary Get Tax Rate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxRatesTaxRate(options?: any): AxiosPromise<object> {
            return localVarFp.getTaxRatesTaxRate(options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Tax Rate
         * @summary Create a Tax Rate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTaxRates(options?: any): AxiosPromise<object> {
            return localVarFp.postTaxRates(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a Tax Rate
         * @summary Update a Tax Rate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTaxRatesTaxRate(options?: any): AxiosPromise<object> {
            return localVarFp.postTaxRatesTaxRate(options).then((request) => request(axios, basePath));
        },
        /**
         * Associates a Tax Rate with a list of Product Types
         * @summary Add Tax Rate to Product Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTaxRatesTaxRateProductTypes(options?: any): AxiosPromise<object> {
            return localVarFp.postTaxRatesTaxRateProductTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * Associates a Tax Rate with a list of Products
         * @summary Add Tax Rate to Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTaxRatesTaxRateProducts(options?: any): AxiosPromise<object> {
            return localVarFp.postTaxRatesTaxRateProducts(options).then((request) => request(axios, basePath));
        },
        /**
         * Associates a Tax Rate with a list of Product Types
         * @summary Add Tax Rate to Product Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTaxRatesTaxRateShippingOptions(options?: any): AxiosPromise<object> {
            return localVarFp.postTaxRatesTaxRateShippingOptions(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaxRatesApi - object-oriented interface
 * @export
 * @class TaxRatesApi
 * @extends {BaseAPI}
 */
export class TaxRatesApi extends BaseAPI {
    /**
     * Deletes a Tax Rate
     * @summary Delete a Tax Rate
     * @param {string} id The id of the Shipping Option.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxRatesApi
     */
    public deleteTaxRatesTaxRate(id: string, options?: AxiosRequestConfig) {
        return TaxRatesApiFp(this.configuration).deleteTaxRatesTaxRate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a Tax Rate from a list of Product Types
     * @summary Remove Tax Rate from Product Types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxRatesApi
     */
    public deleteTaxRatesTaxRateProductTypes(options?: AxiosRequestConfig) {
        return TaxRatesApiFp(this.configuration).deleteTaxRatesTaxRateProductTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a Tax Rate from a list of Products
     * @summary Removes Tax Rate from Products
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxRatesApi
     */
    public deleteTaxRatesTaxRateProducts(options?: AxiosRequestConfig) {
        return TaxRatesApiFp(this.configuration).deleteTaxRatesTaxRateProducts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a Tax Rate from a list of Product Types
     * @summary Removes a Tax Rate from Product Types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxRatesApi
     */
    public deleteTaxRatesTaxRateShippingOptions(options?: AxiosRequestConfig) {
        return TaxRatesApiFp(this.configuration).deleteTaxRatesTaxRateShippingOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a TaxRate
     * @summary Get Tax Rate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxRatesApi
     */
    public getTaxRatesTaxRate(options?: AxiosRequestConfig) {
        return TaxRatesApiFp(this.configuration).getTaxRatesTaxRate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Tax Rate
     * @summary Create a Tax Rate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxRatesApi
     */
    public postTaxRates(options?: AxiosRequestConfig) {
        return TaxRatesApiFp(this.configuration).postTaxRates(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a Tax Rate
     * @summary Update a Tax Rate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxRatesApi
     */
    public postTaxRatesTaxRate(options?: AxiosRequestConfig) {
        return TaxRatesApiFp(this.configuration).postTaxRatesTaxRate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Associates a Tax Rate with a list of Product Types
     * @summary Add Tax Rate to Product Types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxRatesApi
     */
    public postTaxRatesTaxRateProductTypes(options?: AxiosRequestConfig) {
        return TaxRatesApiFp(this.configuration).postTaxRatesTaxRateProductTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Associates a Tax Rate with a list of Products
     * @summary Add Tax Rate to Products
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxRatesApi
     */
    public postTaxRatesTaxRateProducts(options?: AxiosRequestConfig) {
        return TaxRatesApiFp(this.configuration).postTaxRatesTaxRateProducts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Associates a Tax Rate with a list of Product Types
     * @summary Add Tax Rate to Product Types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxRatesApi
     */
    public postTaxRatesTaxRateShippingOptions(options?: AxiosRequestConfig) {
        return TaxRatesApiFp(this.configuration).postTaxRatesTaxRateShippingOptions(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UploadsApi - axios parameter creator
 * @export
 */
export const UploadsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Uploads an array of files to the specific fileservice that is installed in medusa.
         * @summary Uploads an array of files
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUploads: async (files?: Array<any>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UploadsApi - functional programming interface
 * @export
 */
export const UploadsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UploadsApiAxiosParamCreator(configuration)
    return {
        /**
         * Uploads an array of files to the specific fileservice that is installed in medusa.
         * @summary Uploads an array of files
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUploads(files?: Array<any>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUploads(files, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UploadsApi - factory interface
 * @export
 */
export const UploadsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UploadsApiFp(configuration)
    return {
        /**
         * Uploads an array of files to the specific fileservice that is installed in medusa.
         * @summary Uploads an array of files
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUploads(files?: Array<any>, options?: any): AxiosPromise<object> {
            return localVarFp.postUploads(files, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UploadsApi - object-oriented interface
 * @export
 * @class UploadsApi
 * @extends {BaseAPI}
 */
export class UploadsApi extends BaseAPI {
    /**
     * Uploads an array of files to the specific fileservice that is installed in medusa.
     * @summary Uploads an array of files
     * @param {Array<any>} [files] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsApi
     */
    public postUploads(files?: Array<any>, options?: AxiosRequestConfig) {
        return UploadsApiFp(this.configuration).postUploads(files, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a User
         * @summary Delete a User
         * @param {string} userId The id of the User.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersUser: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUsersUser', 'userId', userId)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all users.
         * @summary Retrieve all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a User.
         * @summary Retrieve a User
         * @param {string} id The id of the User.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsersUser', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a User
         * @summary Create a User
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsers: async (uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a User
         * @summary Update a User
         * @param {string} userId The id of the User.
         * @param {InlineObject8} [inlineObject8] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersUser: async (userId: string, inlineObject8?: InlineObject8, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('postUsersUser', 'userId', userId)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject8, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the password for a User given the correct token.
         * @summary Set the password for a User.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersUserPassword: async (uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/password-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a User
         * @summary Delete a User
         * @param {string} userId The id of the User.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUsersUser(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUsersUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves all users.
         * @summary Retrieve all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a User.
         * @summary Retrieve a User
         * @param {string} id The id of the User.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a User
         * @summary Create a User
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsers(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUsers(uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a User
         * @summary Update a User
         * @param {string} userId The id of the User.
         * @param {InlineObject8} [inlineObject8] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersUser(userId: string, inlineObject8?: InlineObject8, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUsersUser(userId, inlineObject8, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets the password for a User given the correct token.
         * @summary Set the password for a User.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersUserPassword(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUsersUserPassword(uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Deletes a User
         * @summary Delete a User
         * @param {string} userId The id of the User.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersUser(userId: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteUsersUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all users.
         * @summary Retrieve all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options?: any): AxiosPromise<object> {
            return localVarFp.getUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a User.
         * @summary Retrieve a User
         * @param {string} id The id of the User.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUser(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.getUsersUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a User
         * @summary Create a User
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsers(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postUsers(uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a User
         * @summary Update a User
         * @param {string} userId The id of the User.
         * @param {InlineObject8} [inlineObject8] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersUser(userId: string, inlineObject8?: InlineObject8, options?: any): AxiosPromise<object> {
            return localVarFp.postUsersUser(userId, inlineObject8, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the password for a User given the correct token.
         * @summary Set the password for a User.
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersUserPassword(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.postUsersUserPassword(uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Deletes a User
     * @summary Delete a User
     * @param {string} userId The id of the User.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUsersUser(userId: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUsersUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all users.
     * @summary Retrieve all users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsers(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a User.
     * @summary Retrieve a User
     * @param {string} id The id of the User.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersUser(id: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a User
     * @summary Create a User
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postUsers(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).postUsers(uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a User
     * @summary Update a User
     * @param {string} userId The id of the User.
     * @param {InlineObject8} [inlineObject8] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postUsersUser(userId: string, inlineObject8?: InlineObject8, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).postUsersUser(userId, inlineObject8, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets the password for a User given the correct token.
     * @summary Set the password for a User.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postUsersUserPassword(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).postUsersUserPassword(uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }
}


